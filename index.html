<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>厦门集美区实时天气</title>

  <link rel="stylesheet" href="/mnt/data/18ec03d5-d340-4a72-a26c-c7118b133a3c.css" />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;800&family=JetBrains+Mono:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    .weather-card{
      background: linear-gradient(180deg,#0d1224cc,#0b0f1dcc);
      border:1px solid var(--border);
      border-radius:18px;
      padding:22px;
      box-shadow:var(--shadow);
      position:relative;
      overflow:hidden;
    }

    /* ====== 炫酷动画层 ====== */
    .wx-anim{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index:0;
      opacity:1;
      overflow:hidden;
    }

    #fxCanvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
      opacity:.88;
      filter: saturate(1.2) contrast(1.05);
    }

    .wx-anim::before{
      content:"";
      position:absolute;
      inset:-40% -30%;
      background:
        radial-gradient(circle at 20% 25%, rgba(0,231,255,.22), transparent 55%),
        radial-gradient(circle at 80% 35%, rgba(255,43,214,.18), transparent 58%),
        radial-gradient(circle at 45% 80%, rgba(120,180,255,.12), transparent 60%);
      filter: blur(18px);
      animation: energyFloat 7s ease-in-out infinite alternate;
      opacity:.95;
    }

    .ring{
      position:absolute;
      left:50%;
      top:50%;
      width:560px;
      height:560px;
      transform:translate(-50%,-50%);
      border-radius:50%;
      background: conic-gradient(
        rgba(0,231,255,0),
        rgba(0,231,255,.28),
        rgba(255,43,214,.20),
        rgba(0,231,255,0)
      );
      filter: blur(7px);
      opacity:.35;
      animation: ringSpin 10s linear infinite;
    }

    .mist{
      position:absolute;
      inset:-30% -30%;
      background:
        radial-gradient(360px 240px at 20% 45%, rgba(210,240,255,.18), transparent 62%),
        radial-gradient(460px 300px at 65% 55%, rgba(180,230,255,.14), transparent 64%),
        radial-gradient(420px 280px at 50% 75%, rgba(150,210,255,.12), transparent 64%);
      filter: blur(16px);
      opacity:0;
      animation: mistDrift 8s ease-in-out infinite alternate;
    }

    .flash{
      position:absolute;
      inset:0;
      background: radial-gradient(circle at 55% 32%, rgba(255,255,255,.95), transparent 35%);
      mix-blend-mode: screen;
      opacity:0;
      animation: flash 4.8s infinite;
      display:none;
    }

    .wx-content{ position:relative; z-index:1; }

    .weather-head{
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:6px;
      margin-bottom:16px;
    }

    .place-main{
      width:100%;
      text-align:center;
      font-family:"Orbitron", system-ui;
      font-size:clamp(28px, 4vw, 42px);
      font-weight:800;
      letter-spacing:.12em;
      margin:0 0 6px;
      color:#dff6ff;
      text-shadow: 0 0 12px var(--neon-cyan), 0 0 26px rgba(255,43,214,.22);
    }

    .updated{
      color:var(--muted);
      font-size:.9rem;
      text-align:center;
      margin-top:2px;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 12px;
      border-radius:999px;
      border:1px solid #24406a;
      background:#0b1326cc;
      color:#d1eeff;
      font-weight:700;
      letter-spacing:.02em;
      box-shadow: inset 0 0 0 1px rgba(0,231,255,.10);
      margin-top:6px;
    }

    .big{
      display:flex;
      align-items:baseline;
      justify-content:center;
      gap:10px;
      margin:8px 0 4px;
    }
    .temp{
      font-size: clamp(48px, 6vw, 72px);
      font-weight:800;
      line-height:1;
      font-family:"Orbitron",system-ui;
      text-shadow: 0 0 14px var(--neon-cyan), 0 0 22px rgba(255,43,214,.20);
    }
    .unit{
      color:#bfeaff;
      opacity:.9;
      font-weight:700;
      letter-spacing:.06em;
    }

    .desc{
      color:var(--muted);
      margin:6px 0 10px;
      line-height:1.6;
      text-align:center;
    }

    .advice{
      margin: 10px 0 18px;
      padding:12px 14px;
      border-radius:14px;
      border:1px solid #24406a;
      background:#0b1326cc;
      box-shadow: inset 0 0 0 1px rgba(0,231,255,.10);
      color:#cfefff;
      line-height:1.65;
    }
    .advice b{
      font-family:"Orbitron",system-ui;
      letter-spacing:.06em;
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap:12px;
    }
    @media (max-width:560px){ .grid{ grid-template-columns: 1fr; } }

    .metric{
      padding:14px 14px;
      border-radius:14px;
      border:1px solid #24406a;
      background:#0b1326cc;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      transition: transform .15s ease, border-color .15s ease, background .15s ease;
    }
    .metric:hover{
      transform: translateY(-2px);
      border-color:#4ac8ff;
      background:#0e1a33;
    }
    .metric .k{ color:#8db3cc; font-size:.9rem; }
    .metric .v{ color:#d1eeff; font-weight:800; letter-spacing:.02em; }

    .actions{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      margin-top:16px;
      justify-content:center;
    }
    .btn{
      cursor:pointer;
      border:1px solid #24406a;
      background:#0b1326cc;
      color:#d1eeff;
      border-radius:12px;
      padding:10px 14px;
      font-weight:800;
      letter-spacing:.03em;
      transition:.15s;
      box-shadow: inset 0 0 0 1px rgba(0,231,255,.10);
    }
    .btn:hover{ transform: translateY(-2px); border-color:#4ac8ff; background:#0e1a33; }
    .btn:active{ transform: translateY(0); }

    .status{
      margin-top:10px;
      color:#9fb5c6;
      font-size:.9rem;
      text-align:center;
    }

    @keyframes energyFloat{
      from{ transform: translate(-2%, -1%) scale(1); }
      to  { transform: translate(2%, 1%) scale(1.06); }
    }
    @keyframes ringSpin{
      from{ transform:translate(-50%,-50%) rotate(0deg); }
      to  { transform:translate(-50%,-50%) rotate(360deg); }
    }
    @keyframes mistDrift{
      from{ transform: translateX(-4%); }
      to  { transform: translateX(4%); }
    }
    @keyframes flash{
      0%,92%,100%{ opacity:0; }
      93%{ opacity:.92; }
      95%{ opacity:.20; }
      97%{ opacity:.98; }
    }

    .wx-clear .ring{ opacity:.55; }
    .wx-clouds .ring{ opacity:.36; }
    .wx-overcast .ring{ opacity:.20; filter: blur(9px); }
    .wx-rain .ring{ opacity:.25; filter: blur(10px); }
    .wx-snow .ring{ opacity:.22; filter: blur(11px); }
    .wx-fog  .ring{ opacity:.14; filter: blur(12px); }
    .wx-thunder .ring{ opacity:.18; filter: blur(12px); }

    .wx-clouds .mist{ opacity:.58; }
    .wx-overcast .mist{ opacity:.72; }
    .wx-thunder .mist{ opacity:.82; }

    .wx-thunder .flash{ display:block; }

    /* ===========================
       ✅ 新增：7天日期切换 UI
    ============================ */
    .forecast-wrap{
      margin-top:14px;
      padding:14px;
      border-radius:16px;
      border:1px solid #24406a;
      background:#0b1326cc;
      box-shadow: inset 0 0 0 1px rgba(0,231,255,.10);
    }
    .forecast-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .forecast-title .h{
      font-family:"Orbitron",system-ui;
      color:#d1eeff;
      letter-spacing:.08em;
      font-weight:800;
    }
    .mode-pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid #24406a;
      background:#0b1326cc;
      color:#bfeaff;
      font-weight:800;
      letter-spacing:.03em;
      box-shadow: inset 0 0 0 1px rgba(0,231,255,.10);
      font-size:.86rem;
      white-space:nowrap;
    }

    .day-tabs{
      display:flex;
      gap:10px;
      flex-wrap:wrap; /* ✅ 移动端自适应换行 */
      justify-content:center;
      margin: 6px 0 12px;
    }
    .day-btn{
      cursor:pointer;
      border:1px solid #24406a;
      background:#081022cc;
      color:#d1eeff;
      border-radius:14px;
      padding:10px 12px;
      font-weight:800;
      letter-spacing:.02em;
      transition:.15s;
      box-shadow: inset 0 0 0 1px rgba(0,231,255,.10);
      min-width: 132px;
      text-align:center;
      position:relative;
      overflow:hidden;
    }
    .day-btn:hover{
      transform: translateY(-2px);
      border-color:#4ac8ff;
      background:#0e1a33;
    }
    .day-btn:active{ transform: translateY(0); }
    .day-btn .d{
      font-family:"Orbitron",system-ui;
      letter-spacing:.06em;
      font-weight:900;
      font-size:.95rem;
      display:block;
      margin-bottom:4px;
      color:#e4fbff;
      text-shadow: 0 0 10px rgba(0,231,255,.20);
    }
    .day-btn .s{
      display:block;
      color:#9fb5c6;
      font-size:.86rem;
      font-weight:700;
    }
    /* ✅ 激活状态样式 */
    .day-btn.active{
      border-color:#4ac8ff;
      background: linear-gradient(180deg, rgba(0,231,255,.10), rgba(255,43,214,.06));
      box-shadow:
        0 0 18px rgba(0,231,255,.18),
        0 0 26px rgba(255,43,214,.12),
        inset 0 0 0 1px rgba(0,231,255,.16);
      transform: translateY(-1px);
    }
    .day-btn.active::after{
      content:"";
      position:absolute;
      inset:-40% -30%;
      background:
        radial-gradient(circle at 25% 35%, rgba(0,231,255,.18), transparent 55%),
        radial-gradient(circle at 75% 60%, rgba(255,43,214,.12), transparent 60%);
      filter: blur(14px);
      opacity:.9;
      pointer-events:none;
    }

    .detail-grid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap:12px;
      margin-top:10px;
    }
    @media (max-width:560px){ .detail-grid{ grid-template-columns: 1fr; } }

    .detail-head{
      text-align:center;
      margin: 4px 0 10px;
      color:#cfefff;
      line-height:1.55;
    }
    .detail-head b{
      font-family:"Orbitron",system-ui;
      letter-spacing:.06em;
      color:#e4fbff;
    }

    /* ===========================
       ✅ 新增：7天折线图（Canvas）
    ============================ */
    .chart-card{
      margin-top:16px;
      border-radius:18px;
      border:1px solid #24406a;
      background: linear-gradient(180deg,#0d1224cc,#0b0f1dcc);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .chart-head{
      padding:14px 16px 10px;
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
      border-bottom: 1px solid rgba(36,64,106,.55);
      background: rgba(11,19,38,.55);
    }
    .chart-head .title{
      font-family:"Orbitron",system-ui;
      color:#dff6ff;
      letter-spacing:.10em;
      font-weight:900;
      text-shadow: 0 0 12px rgba(0,231,255,.20);
    }
    .chart-head .legend{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
      color:#9fb5c6;
      font-size:.86rem;
      font-weight:800;
    }
    .legend .dot{
      width:10px;height:10px;border-radius:50%;
      display:inline-block;margin-right:6px;
      box-shadow: 0 0 12px rgba(0,231,255,.18);
    }
    .legend .dot.max{ background: rgba(0,231,255,.95); }
    .legend .dot.min{ background: rgba(255,43,214,.85); box-shadow: 0 0 12px rgba(255,43,214,.18); }

    .chart-body{
      padding:10px 12px 12px;
      position:relative;
    }
    #trendCanvas{
      width:100%;
      height:260px;
      display:block;
      border-radius:14px;
      background: rgba(9,16,34,.35);
      border: 1px solid rgba(36,64,106,.45);
      box-shadow: inset 0 0 0 1px rgba(0,231,255,.06);
    }
    @media (max-width:560px){
      #trendCanvas{ height: 240px; }
    }

    .tooltip{
      position:absolute;
      pointer-events:none;
      transform: translate(-50%, -110%);
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(74,200,255,.55);
      background: rgba(11,19,38,.92);
      color:#d1eeff;
      font-weight:800;
      letter-spacing:.02em;
      box-shadow: 0 0 18px rgba(0,231,255,.18), 0 0 22px rgba(255,43,214,.10);
      opacity:0;
      transition: opacity .08s ease;
      white-space:nowrap;
      z-index:3;
    }
    .tooltip .sub{
      display:block;
      color:#9fb5c6;
      font-size:.82rem;
      font-weight:700;
      margin-top:4px;
    }
  </style>
</head>

<body>
  <div class="bg fx-grid"></div>
  <div class="bg fx-noise"></div>
  <div class="bg fx-scanline"></div>

  <main class="container">
    <section class="hero-card">
      <div class="weather-card" aria-live="polite">
        <div class="wx-anim wx-clear" id="wxAnim">
          <canvas id="fxCanvas"></canvas>
          <div class="ring"></div>
          <div class="mist"></div>
          <div class="flash"></div>
        </div>

        <div class="wx-content">
          <div class="weather-head">
            <h1 class="place-main">厦门 · 集美区</h1>
            <div class="updated" id="updatedText">正在获取最新天气…</div>
            <div class="pill" id="badge">● 加载中</div>
          </div>

          <div class="big">
            <div class="temp" id="temp">--</div>
            <div class="unit">°C</div>
          </div>

          <div class="desc" id="desc">请稍候，正在加载实时天气信息。</div>

          <div class="advice" id="advice"><b>出行建议：</b>正在生成建议…</div>

          <div class="grid" id="metrics">
            <div class="metric"><span class="k">体感温度</span><span class="v" id="apparent">-- °C</span></div>
            <div class="metric"><span class="k">风速</span><span class="v" id="wind">-- km/h</span></div>
            <div class="metric"><span class="k">湿度</span><span class="v" id="humidity">-- %</span></div>
            <div class="metric"><span class="k">气压</span><span class="v" id="pressure">-- hPa</span></div>
            <div class="metric"><span class="k">降水</span><span class="v" id="precip">-- mm</span></div>
            <div class="metric"><span class="k">云量</span><span class="v" id="cloud">-- %</span></div>
            <div class="metric"><span class="k">能见度</span><span class="v" id="visibility">-- km</span></div>
            <div class="metric"><span class="k">UV 指数</span><span class="v" id="uv">--</span></div>
          </div>

          <!-- ✅ 新增：未来7天日期切换 + 详情展示 -->
          <div class="forecast-wrap" id="forecastWrap">
            <div class="forecast-title">
              <div class="h">未来 7 天预报</div>
              <div class="mode-pill" id="modePill">当前：实时</div>
            </div>

            <div class="day-tabs" id="dayTabs">
              <!-- JS 动态生成 7 个按钮 -->
            </div>

            <div class="detail-head" id="detailHead">
              <b>提示：</b>默认展示实时天气。点击上方日期按钮切换查看对应日期预报（不影响粒子特效与整体布局）。
            </div>

            <div class="detail-grid" id="detailGrid">
              <div class="metric"><span class="k">温度范围</span><span class="v" id="dTempRange">--</span></div>
              <div class="metric"><span class="k">天气状况</span><span class="v" id="dWeather">--</span></div>
              <div class="metric"><span class="k">最大风速</span><span class="v" id="dWindMax">--</span></div>
              <div class="metric"><span class="k">湿度（均值）</span><span class="v" id="dHumidityAvg">--</span></div>
              <div class="metric"><span class="k">降水概率</span><span class="v" id="dPrecipProb">--</span></div>
              <div class="metric"><span class="k">预计降水量</span><span class="v" id="dPrecipSum">--</span></div>
              <div class="metric"><span class="k">UV 最大值</span><span class="v" id="dUvMax">--</span></div>
              <div class="metric"><span class="k">能见度（均值）</span><span class="v" id="dVisibilityAvg">--</span></div>
            </div>
          </div>

          <div class="actions">
            <button class="btn" id="refreshBtn" type="button">手动刷新</button>
            <button class="btn" id="toggleAutoBtn" type="button">自动刷新：开启</button>
            <!-- ✅ 可选：一键回到实时 -->
            <button class="btn" id="backToLiveBtn" type="button">返回实时</button>
          </div>

          <div class="status" id="status"></div>

          <!-- ✅ 新增：7天折线图（位于 footer 上方） -->
          <div class="chart-card" id="chartCard" aria-label="未来7天温度趋势图">
            <div class="chart-head">
              <div class="title">7-DAY TEMP TREND</div>
              <div class="legend">
                <span><i class="dot max"></i>最高气温</span>
                <span><i class="dot min"></i>最低气温</span>
              </div>
            </div>
            <div class="chart-body">
              <canvas id="trendCanvas"></canvas>
              <div class="tooltip" id="tooltip"></div>
            </div>
          </div>

        </div>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    © <span id="year"></span> Xiamen Jimei Weather · Cyber UI
  </footer>

  <script>
    const LAT = 24.58;
    const LON = 118.10;

    let autoRefresh = true;
    let timer = null;
    const AUTO_INTERVAL_MS = 5 * 60 * 1000;

    // ✅ 新增：预报/实时切换状态
    let selectedDayIndex = -1; // -1 = 实时；0..6 = 未来7天中的某天
    let lastWeatherPayload = null;

    const el = (id) => document.getElementById(id);
    const tempEl = el("temp");
    const descEl = el("desc");
    const badgeEl = el("badge");
    const updatedEl = el("updatedText");
    const statusEl = el("status");
    const adviceEl = el("advice");
    const animEl = el("wxAnim");
    const modePillEl = el("modePill");

    const apparentEl = el("apparent");
    const windEl = el("wind");
    const humidityEl = el("humidity");
    const pressureEl = el("pressure");
    const precipEl = el("precip");
    const cloudEl = el("cloud");
    const visibilityEl = el("visibility");
    const uvEl = el("uv");

    const refreshBtn = el("refreshBtn");
    const toggleAutoBtn = el("toggleAutoBtn");
    const backToLiveBtn = el("backToLiveBtn");

    // ✅ 新增：预报按钮/详情
    const dayTabsEl = el("dayTabs");
    const dTempRangeEl = el("dTempRange");
    const dWeatherEl = el("dWeather");
    const dWindMaxEl = el("dWindMax");
    const dHumidityAvgEl = el("dHumidityAvg");
    const dPrecipProbEl = el("dPrecipProb");
    const dPrecipSumEl = el("dPrecipSum");
    const dUvMaxEl = el("dUvMax");
    const dVisibilityAvgEl = el("dVisibilityAvg");
    const detailHeadEl = el("detailHead");

    // ✅ 新增：折线图
    const trendCanvas = el("trendCanvas");
    const tctx = trendCanvas.getContext("2d");
    const tooltipEl = el("tooltip");
    let trendDpr = Math.max(1, window.devicePixelRatio || 1);
    let trendModel = null; // {days:[{date,label,code,desc,tmax,tmin}], minY,maxY, pointsMax[], pointsMin[]}

    function weatherText(code) {
      const map = {
        0: "晴朗", 1: "大致晴", 2: "多云", 3: "阴天",
        45: "雾", 48: "雾凇",
        51: "毛毛雨（弱）", 53: "毛毛雨（中）", 55: "毛毛雨（强）",
        56: "冻毛毛雨（弱）", 57: "冻毛毛雨（强）",
        61: "小雨", 63: "中雨", 65: "大雨",
        66: "冻雨（弱）", 67: "冻雨（强）",
        71: "小雪", 73: "中雪", 75: "大雪", 77: "雪粒",
        80: "阵雨（弱）", 81: "阵雨（中）", 82: "阵雨（强）",
        85: "阵雪（弱）", 86: "阵雪（强）",
        95: "雷暴", 96: "雷暴伴随冰雹（弱）", 99: "雷暴伴随冰雹（强）",
      };
      return map[code] ?? `未知天气（code ${code}）`;
    }

    function windDirText(deg) {
      if (deg == null || Number.isNaN(deg)) return "";
      const dirs = ["北", "东北", "东", "东南", "南", "西南", "西", "西北"];
      const i = Math.round(deg / 45) % 8;
      return dirs[i];
    }

    function fmt(n, digits = 0) {
      if (n == null || Number.isNaN(n)) return "--";
      return Number(n).toFixed(digits);
    }

    function setBadge(text, mode = "ok") {
      badgeEl.textContent = text;
      if (mode === "ok") {
        badgeEl.style.borderColor = "#24406a";
        badgeEl.style.boxShadow = "inset 0 0 0 1px rgba(0,231,255,.10)";
      } else if (mode === "warn") {
        badgeEl.style.borderColor = "#ff2bd655";
        badgeEl.style.boxShadow = "0 0 18px rgba(255,43,214,.22)";
      } else {
        badgeEl.style.borderColor = "#8a6bff55";
        badgeEl.style.boxShadow = "0 0 18px rgba(138,107,255,.22)";
      }
    }

    /* ========= Canvas 粒子特效引擎（按天气切换） ========= */
    const canvas = document.getElementById("fxCanvas");
    const ctx = canvas.getContext("2d");

    let fxMode = "clear";
    let fxWind = 0;
    let fxIntensity = 1;
    let dpr = Math.max(1, window.devicePixelRatio || 1);

    const particles = [];
    const sparks = [];

    function resizeCanvas(){
      const r = canvas.getBoundingClientRect();
      const w = Math.max(1, r.width);
      const h = Math.max(1, r.height);
      canvas.width  = Math.round(w * dpr);
      canvas.height = Math.round(h * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    window.addEventListener("resize", () => {
      resizeCanvas();
      resizeTrendCanvas();
      drawTrend();
    });

    function rand(a,b){ return a + Math.random()*(b-a); }

    function spawn(){
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;
      const count = Math.floor(7 * fxIntensity);

      if (fxMode === "rain" || fxMode === "thunder"){
        for (let i=0;i<count*3;i++){
          particles.push({
            x: rand(-20, w+20),
            y: rand(-h, 0),
            vx: rand(0.6, 1.6) + fxWind*0.03,
            vy: rand(9, 16) + fxIntensity*2.0,
            len: rand(14, 28),
            a: rand(0.14, 0.32)
          });
        }
      } else if (fxMode === "snow"){
        for (let i=0;i<count*2;i++){
          particles.push({
            x: rand(-20, w+20),
            y: rand(-h, 0),
            vx: rand(-0.7, 0.9) + fxWind*0.02,
            vy: rand(1.1, 2.8) + fxIntensity*0.25,
            r: rand(0.8, 2.4),
            tw: rand(0.004, 0.012),
            t: rand(0, 999)
          });
        }
      } else if (fxMode === "fog" || fxMode === "clouds" || fxMode === "overcast"){
        for (let i=0;i<count;i++){
          particles.push({
            x: rand(-80, w+80),
            y: rand(0, h),
            vx: rand(0.18, 0.55) + fxWind*0.01,
            vy: rand(-0.05, 0.05),
            r: rand(70, 160),
            a: rand(0.03, 0.085)
          });
        }
      } else {
        for (let i=0;i<count;i++){
          particles.push({
            x: rand(0, w),
            y: rand(0, h),
            vx: rand(-0.14, 0.14),
            vy: rand(-0.12, 0.12),
            r: rand(0.6, 1.8),
            a: rand(0.10, 0.24),
            tw: rand(0.006, 0.016),
            t: rand(0, 999)
          });
        }
      }
    }

    function lightning(){
      if (fxMode !== "thunder") return;
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;
      const x0 = rand(w*0.35, w*0.7);
      const y0 = rand(0, h*0.25);

      for (let i=0;i<22;i++){
        sparks.push({
          x: x0 + rand(-12,12),
          y: y0 + rand(-8,8),
          vx: rand(-3.0,3.0),
          vy: rand(0.8,5.0),
          life: rand(14, 28),
          a: rand(0.25, 0.65)
        });
      }
    }

    let lastLightning = 0;

    function step(){
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;

      ctx.clearRect(0,0,w,h);

      if (particles.length < 420) spawn();

      if (fxMode === "thunder"){
        const now = performance.now();
        if (now - lastLightning > rand(1100, 2400)){
          lastLightning = now;
          lightning();
        }
      }

      for (let i=particles.length-1;i>=0;i--){
        const p = particles[i];

        if (fxMode === "rain" || fxMode === "thunder"){
          p.x += p.vx;
          p.y += p.vy;

          ctx.globalAlpha = p.a;
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(p.x - p.vx*2.0, p.y - p.len);
          ctx.strokeStyle = "rgba(210,245,255,0.95)";
          ctx.lineWidth = 1;
          ctx.stroke();

          if (p.y > h+40 || p.x < -60 || p.x > w+60) particles.splice(i,1);
        }
        else if (fxMode === "snow"){
          p.t += 1;
          const tw = (Math.sin(p.t * p.tw) + 1) * 0.5;
          p.x += p.vx + Math.sin(p.t*0.02)*0.18;
          p.y += p.vy;

          ctx.globalAlpha = 0.12 + tw * 0.38;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
          ctx.fillStyle = "rgba(240,252,255,0.95)";
          ctx.fill();

          if (p.y > h+24) particles.splice(i,1);
        }
        else if (fxMode === "fog" || fxMode === "clouds" || fxMode === "overcast"){
          p.x += p.vx;
          p.y += p.vy;

          ctx.globalAlpha = p.a;
          const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r);
          g.addColorStop(0, "rgba(220,245,255,0.55)");
          g.addColorStop(1, "rgba(220,245,255,0)");
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
          ctx.fill();

          if (p.x > w+160) p.x = -160;
        }
        else {
          p.t += 1;
          const tw = (Math.sin(p.t * p.tw) + 1) * 0.5;
          p.x += p.vx;
          p.y += p.vy;

          if (p.x < 0) p.x = w;
          if (p.x > w) p.x = 0;
          if (p.y < 0) p.y = h;
          if (p.y > h) p.y = 0;

          ctx.globalAlpha = p.a + tw*0.22;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
          ctx.fillStyle = "rgba(190,245,255,0.95)";
          ctx.fill();
        }
      }

      for (let i=sparks.length-1;i>=0;i--){
        const s = sparks[i];
        s.x += s.vx;
        s.y += s.vy;
        s.vy += 0.12;
        s.life -= 1;

        ctx.globalAlpha = s.a * Math.max(0, s.life/28);
        ctx.beginPath();
        ctx.arc(s.x, s.y, 1.6, 0, Math.PI*2);
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fill();

        if (s.life <= 0) sparks.splice(i,1);
      }

      requestAnimationFrame(step);
    }

    function setFx(mode, windKmh){
      fxMode = mode;
      fxWind = windKmh ?? 0;

      if (mode === "thunder") fxIntensity = 2.7;
      else if (mode === "rain") fxIntensity = 2.1;
      else if (mode === "snow") fxIntensity = 1.7;
      else if (mode === "fog") fxIntensity = 1.9;
      else if (mode === "overcast") fxIntensity = 1.55;
      else if (mode === "clouds") fxIntensity = 1.35;
      else fxIntensity = 1.15;

      particles.length = 0;
      sparks.length = 0;
      spawn();
    }

    function animClassByCode(code){
      if ([95,96,99].includes(code)) return "wx-thunder";
      if ([45,48].includes(code)) return "wx-fog";
      if ([71,73,75,77,85,86].includes(code)) return "wx-snow";
      if ([51,53,55,56,57,61,63,65,66,67,80,81,82].includes(code)) return "wx-rain";
      if (code === 3) return "wx-overcast";
      if (code === 2) return "wx-clouds";
      if (code === 0 || code === 1) return "wx-clear";
      return "wx-clouds";
    }
    function fxModeByClass(cls){
      if (cls === "wx-thunder") return "thunder";
      if (cls === "wx-fog") return "fog";
      if (cls === "wx-snow") return "snow";
      if (cls === "wx-rain") return "rain";
      if (cls === "wx-overcast") return "overcast";
      if (cls === "wx-clouds") return "clouds";
      return "clear";
    }

    function setAnim(code, wind){
      const cls = animClassByCode(code);
      animEl.className = `wx-anim ${cls}`;
      resizeCanvas();
      setFx(fxModeByClass(cls), wind);
    }

    function makeAdvice({ code, temp, wind, precip, uv, visibilityKm }){
      const tips = [];

      if ([95,96,99].includes(code)) tips.push("尽量避免空旷地/海边停留，注意雷电与突发强降雨。");
      if ([45,48].includes(code)) tips.push("雾较明显：慢行、开雾灯，骑行注意安全。");
      if ([71,73,75,77,85,86].includes(code)) tips.push("路面可能湿滑：建议防滑鞋，谨慎驾驶。");
      if ([51,53,55,56,57,61,63,65,66,67,80,81,82].includes(code)) tips.push("建议随身带伞/雨衣，鞋子尽量防水。");

      if (temp != null) {
        if (temp >= 30) tips.push("体感偏热：轻薄透气，及时补水。");
        else if (temp <= 12) tips.push("体感偏凉：加外套，早晚保暖。");
        else tips.push("体感舒适：适合户外活动。");
      }

      if (wind != null) {
        if (wind >= 35) tips.push("风较大：减少骑行/高处停留，注意落物。");
        else if (wind >= 20) tips.push("有风：可备轻薄外套。");
      }

      if (uv != null) {
        if (uv >= 8) tips.push("UV 很强：防晒霜+帽子/墨镜，尽量避开正午暴晒。");
        else if (uv >= 5) tips.push("UV 较强：建议适度防晒。");
      }

      if (visibilityKm != null && visibilityKm < 3) tips.push("能见度较低：注意车距，避免急刹。");
      if (precip != null && precip >= 2) tips.push("降水偏多：尽量走有遮挡路线，注意积水。");

      const text = tips.length ? tips.join(" ") : "天气信息不足，建议关注路况并备好雨具/外套。";
      return `<b>出行建议：</b>${text}`;
    }

    // ✅ 找 hourly.time 里“最接近 current.time”的索引（兜底用）
    function findClosestTimeIndex(times, targetIso){
      if (!Array.isArray(times) || !times.length || !targetIso) return -1;
      const target = Date.parse(targetIso);
      if (!Number.isFinite(target)) return -1;

      let best = 0;
      let bestDiff = Infinity;
      for (let i=0;i<times.length;i++){
        const t = Date.parse(times[i]);
        if (!Number.isFinite(t)) continue;
        const diff = Math.abs(t - target);
        if (diff < bestDiff){
          bestDiff = diff;
          best = i;
        }
      }
      return bestDiff === Infinity ? -1 : best;
    }

    // ✅ 新增：把 yyyy-mm-dd 转成 “1月5日”
    function formatCNDate(isoDate){
      const d = new Date(isoDate + "T00:00:00");
      const m = d.getMonth() + 1;
      const day = d.getDate();
      return `${m}月${day}日`;
    }

    // ✅ 新增：按日聚合 hourly（用于湿度/能见度等）
    function aggregateHourlyByDate(hourly){
      const map = new Map();
      const times = hourly?.time || [];
      function pushVal(dateKey, key, v){
        if (!map.has(dateKey)) map.set(dateKey, {});
        const obj = map.get(dateKey);
        if (!Array.isArray(obj[key])) obj[key] = [];
        if (v != null && Number.isFinite(v)) obj[key].push(v);
      }
      for (let i=0;i<times.length;i++){
        const t = times[i]; // "YYYY-MM-DDTHH:mm"
        const dateKey = String(t).slice(0,10);
        pushVal(dateKey, "humidity", hourly?.relative_humidity_2m?.[i]);
        pushVal(dateKey, "visibility", hourly?.visibility?.[i]);
      }
      function avg(arr){
        if (!arr || !arr.length) return null;
        let s = 0;
        for (const x of arr) s += x;
        return s / arr.length;
      }
      const out = new Map();
      for (const [date, obj] of map.entries()){
        out.set(date, {
          humidityAvg: avg(obj.humidity),
          visibilityAvg: avg(obj.visibility)
        });
      }
      return out;
    }

    // ✅ 新增：生成 7 天按钮
    function buildDayTabs(days){
      dayTabsEl.innerHTML = "";
      days.forEach((d, i) => {
        const btn = document.createElement("button");
        btn.className = "day-btn";
        btn.type = "button";
        btn.dataset.index = String(i);
        btn.innerHTML = `<span class="d">${d.label}</span><span class="s">${d.desc}</span>`;
        btn.addEventListener("click", () => {
          selectedDayIndex = i;
          updateActiveTab();
          renderByMode(); // 切换展示（不破坏粒子特效）
        });
        dayTabsEl.appendChild(btn);
      });
      updateActiveTab();
    }

    function updateActiveTab(){
      const btns = dayTabsEl.querySelectorAll(".day-btn");
      btns.forEach((b) => {
        const i = Number(b.dataset.index);
        b.classList.toggle("active", i === selectedDayIndex);
      });
    }

    function setModePill(){
      if (selectedDayIndex === -1) {
        modePillEl.textContent = "当前：实时";
      } else if (trendModel?.days?.[selectedDayIndex]) {
        modePillEl.textContent = `当前：${trendModel.days[selectedDayIndex].label} 预报`;
      } else {
        modePillEl.textContent = "当前：预报";
      }
    }

    // ✅ 折线图：尺寸 & 绘制
    function resizeTrendCanvas(){
      const r = trendCanvas.getBoundingClientRect();
      const w = Math.max(1, r.width);
      const h = Math.max(1, r.height);
      trendCanvas.width  = Math.round(w * trendDpr);
      trendCanvas.height = Math.round(h * trendDpr);
      tctx.setTransform(trendDpr,0,0,trendDpr,0,0);
    }

    function buildTrendModel(days){
      // 取 min/max 用于映射
      const vals = [];
      for (const d of days){
        if (Number.isFinite(d.tmax)) vals.push(d.tmax);
        if (Number.isFinite(d.tmin)) vals.push(d.tmin);
      }
      let minY = Math.min(...vals);
      let maxY = Math.max(...vals);
      if (!Number.isFinite(minY) || !Number.isFinite(maxY)) {
        minY = 0; maxY = 40;
      }
      // 留出上下边距
      const pad = Math.max(2, (maxY - minY) * 0.15);
      minY -= pad; maxY += pad;

      trendModel = { days, minY, maxY, pointsMax: [], pointsMin: [] };
    }

    function drawTrend(){
      if (!trendModel) return;
      const w = trendCanvas.getBoundingClientRect().width;
      const h = trendCanvas.getBoundingClientRect().height;

      const padL = 42;
      const padR = 18;
      const padT = 20;
      const padB = 34;

      tctx.clearRect(0,0,w,h);

      // 背景微光网格
      tctx.save();
      tctx.globalAlpha = 0.9;
      // 网格线
      const gridY = 5;
      const gridX = 7;
      for (let i=0;i<=gridY;i++){
        const y = padT + (h - padT - padB) * (i/gridY);
        tctx.beginPath();
        tctx.moveTo(padL, y);
        tctx.lineTo(w - padR, y);
        tctx.strokeStyle = "rgba(36,64,106,.35)";
        tctx.lineWidth = 1;
        tctx.stroke();
      }
      for (let i=0;i<=gridX;i++){
        const x = padL + (w - padL - padR) * (i/gridX);
        tctx.beginPath();
        tctx.moveTo(x, padT);
        tctx.lineTo(x, h - padB);
        tctx.strokeStyle = "rgba(36,64,106,.22)";
        tctx.lineWidth = 1;
        tctx.stroke();
      }
      tctx.restore();

      const { minY, maxY, days } = trendModel;

      function yOf(v){
        const t = (v - minY) / (maxY - minY);
        return (h - padB) - t * (h - padT - padB);
      }
      function xOf(i){
        const n = days.length;
        if (n === 1) return padL + (w - padL - padR) / 2;
        return padL + (w - padL - padR) * (i/(n-1));
      }

      // 轴标注（Y：3档）
      tctx.save();
      tctx.font = '700 12px "JetBrains Mono", monospace';
      tctx.fillStyle = "rgba(159,181,198,.90)";
      const ticks = 3;
      for (let i=0;i<=ticks;i++){
        const v = minY + (maxY - minY) * (i/ticks);
        const y = yOf(v);
        tctx.fillText(`${Math.round(v)}°`, 8, y+4);
      }
      tctx.restore();

      // X 轴日期（7个）
      tctx.save();
      tctx.font = '800 12px "JetBrains Mono", monospace';
      tctx.fillStyle = "rgba(159,181,198,.92)";
      for (let i=0;i<days.length;i++){
        const x = xOf(i);
        const y = h - 12;
        const txt = days[i].label.replace("月","/").replace("日","");
        const tw = tctx.measureText(txt).width;
        tctx.fillText(txt, x - tw/2, y);
      }
      tctx.restore();

      // 计算点
      trendModel.pointsMax = days.map((d,i) => ({ x: xOf(i), y: yOf(d.tmax), v: d.tmax, i }));
      trendModel.pointsMin = days.map((d,i) => ({ x: xOf(i), y: yOf(d.tmin), v: d.tmin, i }));

      // 画线（霓虹：shadowBlur）
      function drawLine(points, stroke, shadow){
        tctx.save();
        tctx.lineWidth = 2.6;
        tctx.lineJoin = "round";
        tctx.lineCap = "round";
        tctx.strokeStyle = stroke;
        tctx.shadowColor = shadow;
        tctx.shadowBlur = 16;
        tctx.beginPath();
        points.forEach((p, idx) => {
          if (idx === 0) tctx.moveTo(p.x, p.y);
          else tctx.lineTo(p.x, p.y);
        });
        tctx.stroke();
        tctx.restore();
      }

      // 实线：最高（青）
      drawLine(trendModel.pointsMax, "rgba(0,231,255,.95)", "rgba(0,231,255,.55)");
      // 虚线：最低（粉）
      tctx.save();
      tctx.setLineDash([8,6]);
      drawLine(trendModel.pointsMin, "rgba(255,43,214,.88)", "rgba(255,43,214,.50)");
      tctx.restore();

      // 点
      function drawPoints(points, fill, shadow){
        tctx.save();
        tctx.shadowColor = shadow;
        tctx.shadowBlur = 18;
        points.forEach(p => {
          tctx.beginPath();
          tctx.arc(p.x, p.y, 3.8, 0, Math.PI*2);
          tctx.fillStyle = fill;
          tctx.fill();
          // 外圈
          tctx.beginPath();
          tctx.arc(p.x, p.y, 7.2, 0, Math.PI*2);
          tctx.strokeStyle = "rgba(255,255,255,.08)";
          tctx.lineWidth = 1;
          tctx.stroke();
        });
        tctx.restore();
      }
      drawPoints(trendModel.pointsMax, "rgba(0,231,255,.95)", "rgba(0,231,255,.45)");
      drawPoints(trendModel.pointsMin, "rgba(255,43,214,.90)", "rgba(255,43,214,.40)");

      // 如果当前是预报模式，高亮选中日
      if (selectedDayIndex >= 0 && selectedDayIndex < days.length){
        const pmx = trendModel.pointsMax[selectedDayIndex];
        const pmn = trendModel.pointsMin[selectedDayIndex];
        tctx.save();
        tctx.globalAlpha = 0.65;
        tctx.beginPath();
        tctx.moveTo(pmx.x, padT);
        tctx.lineTo(pmx.x, h - padB);
        tctx.strokeStyle = "rgba(0,231,255,.18)";
        tctx.lineWidth = 2;
        tctx.stroke();
        tctx.restore();

        // 更亮一点的点
        tctx.save();
        tctx.shadowBlur = 22;
        tctx.shadowColor = "rgba(0,231,255,.70)";
        tctx.beginPath(); tctx.arc(pmx.x, pmx.y, 5.2, 0, Math.PI*2);
        tctx.fillStyle = "rgba(0,231,255,1)";
        tctx.fill();
        tctx.shadowColor = "rgba(255,43,214,.65)";
        tctx.beginPath(); tctx.arc(pmn.x, pmn.y, 5.2, 0, Math.PI*2);
        tctx.fillStyle = "rgba(255,43,214,1)";
        tctx.fill();
        tctx.restore();
      }
    }

    function showTooltip(x, y, html){
      tooltipEl.innerHTML = html;
      tooltipEl.style.left = `${x}px`;
      tooltipEl.style.top  = `${y}px`;
      tooltipEl.style.opacity = "1";
    }
    function hideTooltip(){
      tooltipEl.style.opacity = "0";
    }

    function nearestPoint(mx, my){
      if (!trendModel) return null;
      const pts = [...trendModel.pointsMax, ...trendModel.pointsMin];
      let best = null;
      let bestD = Infinity;
      for (const p of pts){
        const dx = mx - p.x;
        const dy = my - p.y;
        const d2 = dx*dx + dy*dy;
        if (d2 < bestD){
          bestD = d2;
          best = p;
        }
      }
      return bestD <= (16*16) ? best : null;
    }

    trendCanvas.addEventListener("mousemove", (e) => {
      if (!trendModel) return;
      const r = trendCanvas.getBoundingClientRect();
      const mx = e.clientX - r.left;
      const my = e.clientY - r.top;
      const p = nearestPoint(mx, my);
      if (!p){ hideTooltip(); return; }
      const d = trendModel.days[p.i];
      const isMax = trendModel.pointsMax.some(pm => pm.i === p.i && pm.x === p.x && pm.y === p.y && pm.v === p.v);
      const label = isMax ? "最高" : "最低";
      const html = `${d.label} · ${d.desc}<span class="sub">${label}：${Math.round(p.v)}°C</span>`;
      showTooltip(p.x, p.y, html);
    });
    trendCanvas.addEventListener("mouseleave", hideTooltip);
    trendCanvas.addEventListener("click", (e) => {
      // ✅ 可选交互：点击节点附近，切到对应日期预报
      if (!trendModel) return;
      const r = trendCanvas.getBoundingClientRect();
      const mx = e.clientX - r.left;
      const my = e.clientY - r.top;
      const p = nearestPoint(mx, my);
      if (!p) return;
      selectedDayIndex = p.i;
      updateActiveTab();
      renderByMode();
    });

    function renderLiveFromPayload(data){
      const cur = data.current || {};
      const temp = cur.temperature_2m;
      const app = cur.apparent_temperature;
      const code = cur.weather_code;
      const wind = cur.wind_speed_10m;
      const windDir = cur.wind_direction_10m;
      const time = cur.time;

      // 优先从 current
      let humidity = cur.relative_humidity_2m;
      let pressure = cur.pressure_msl;
      let precip = cur.precipitation;
      let cloud = cur.cloud_cover;
      let visibility = cur.visibility;
      let uv = cur.uv_index;

      // 兜底 hourly 最近时间点
      const hourly = data.hourly || {};
      const times = hourly.time || [];
      const idx = findClosestTimeIndex(times, time);

      if (humidity == null && idx >= 0) humidity = hourly.relative_humidity_2m?.[idx];
      if (pressure == null && idx >= 0) pressure = hourly.pressure_msl?.[idx];
      if (precip == null && idx >= 0) precip = hourly.precipitation?.[idx];
      if (cloud == null && idx >= 0) cloud = hourly.cloud_cover?.[idx];
      if (visibility == null && idx >= 0) visibility = hourly.visibility?.[idx];
      if (uv == null && idx >= 0) uv = hourly.uv_index?.[idx];

      // ✅ 粒子特效按当前展示模式决定（实时模式才用实时 code）
      setAnim(code, wind);

      tempEl.textContent = fmt(temp, 0);
      apparentEl.textContent = `${fmt(app, 0)} °C`;
      windEl.textContent = `${fmt(wind, 0)} km/h ${windDirText(windDir)}`;
      humidityEl.textContent = `${fmt(humidity, 0)} %`;
      pressureEl.textContent = `${fmt(pressure, 0)} hPa`;
      precipEl.textContent = `${fmt(precip, 1)} mm`;
      cloudEl.textContent = `${fmt(cloud, 0)} %`;
      visibilityEl.textContent = visibility == null ? "-- km" : `${fmt(visibility / 1000, 1)} km`;
      uvEl.textContent = fmt(uv, 1);

      const text = weatherText(code);
      descEl.textContent = `${text} · 当前温度 ${fmt(temp, 0)}°C，体感 ${fmt(app, 0)}°C。`;

      const visibilityKm = visibility == null ? null : (visibility / 1000);
      adviceEl.innerHTML = makeAdvice({ code, temp, wind, precip, uv, visibilityKm });

      const dt = time ? new Date(time) : new Date();
      updatedEl.textContent = `更新时间：${dt.toLocaleString("zh-CN", { hour12: false })}`;

      setBadge(`● ${text}`, "ok");
    }

    function renderForecastDetailsFromPayload(data, dayIndex){
      const daily = data.daily || {};
      const dates = daily.time || [];
      if (!dates.length) return;

      const i = Math.max(0, Math.min(dayIndex, dates.length - 1));
      const dateIso = dates[i];

      const tmax = daily.temperature_2m_max?.[i];
      const tmin = daily.temperature_2m_min?.[i];
      const code = daily.weather_code?.[i];
      const windMax = daily.wind_speed_10m_max?.[i];
      const precipProb = daily.precipitation_probability_max?.[i];
      const precipSum = daily.precipitation_sum?.[i];
      const uvMax = daily.uv_index_max?.[i];

      // hourly 日均：湿度/能见度
      const hourlyAgg = aggregateHourlyByDate(data.hourly);
      const agg = hourlyAgg.get(dateIso) || {};
      const humidityAvg = agg.humidityAvg;
      const visibilityAvg = agg.visibilityAvg;

      const desc = weatherText(code);
      const label = formatCNDate(dateIso);

      // ✅ 切换主展示为该天的“预报概览”
      tempEl.textContent = `${fmt(tmax,0)}/${fmt(tmin,0)}`;
      apparentEl.textContent = `--`;
      windEl.textContent = `${fmt(windMax, 0)} km/h`;
      humidityEl.textContent = humidityAvg == null ? "-- %" : `${fmt(humidityAvg, 0)} %`;
      pressureEl.textContent = `-- hPa`;
      precipEl.textContent = precipSum == null ? "-- mm" : `${fmt(precipSum, 1)} mm`;
      cloudEl.textContent = `-- %`;
      visibilityEl.textContent = visibilityAvg == null ? "-- km" : `${fmt(visibilityAvg/1000, 1)} km`;
      uvEl.textContent = uvMax == null ? "--" : fmt(uvMax, 1);

      descEl.textContent = `${label} · ${desc} · 最高 ${fmt(tmax,0)}°C / 最低 ${fmt(tmin,0)}°C。`;

      // ✅ 粒子特效：按预报的 code + windMax
      setAnim(code, windMax);

      // ✅ 预报建议（用 tmax 近似 temp）
      const visibilityKm = visibilityAvg == null ? null : (visibilityAvg/1000);
      adviceEl.innerHTML = makeAdvice({
        code,
        temp: tmax,
        wind: windMax,
        precip: precipSum,
        uv: uvMax,
        visibilityKm
      });

      updatedEl.textContent = `预报日期：${label}（Asia/Shanghai）`;
      setBadge(`● ${desc}`, "ok");

      // ✅ 详情面板
      detailHeadEl.innerHTML = `<b>预报详情：</b>${label} · ${desc}`;
      dTempRangeEl.textContent = `${fmt(tmin,0)}°C ~ ${fmt(tmax,0)}°C`;
      dWeatherEl.textContent = desc;
      dWindMaxEl.textContent = `${fmt(windMax,0)} km/h`;
      dHumidityAvgEl.textContent = humidityAvg == null ? "-- %" : `${fmt(humidityAvg,0)} %`;
      dPrecipProbEl.textContent = precipProb == null ? "-- %" : `${fmt(precipProb,0)} %`;
      dPrecipSumEl.textContent = precipSum == null ? "-- mm" : `${fmt(precipSum,1)} mm`;
      dUvMaxEl.textContent = uvMax == null ? "--" : fmt(uvMax,1);
      dVisibilityAvgEl.textContent = visibilityAvg == null ? "-- km" : `${fmt(visibilityAvg/1000,1)} km`;
    }

    function renderByMode(){
      setModePill();

      // 高亮图表选中日
      drawTrend();

      if (!lastWeatherPayload) return;

      if (selectedDayIndex === -1){
        // ✅ 实时展示：渲染实时 + 详情区保留提示/或显示今天预报也可以
        renderLiveFromPayload(lastWeatherPayload);

        // 详情区：默认可展示“今天预报”（更有用）
        const daily = lastWeatherPayload.daily || {};
        const todayCode = daily.weather_code?.[0];
        const todayDesc = weatherText(todayCode);
        const todayIso = daily.time?.[0];
        if (todayIso){
          detailHeadEl.innerHTML = `<b>今日预报：</b>${formatCNDate(todayIso)} · ${todayDesc}（实时展示仍为上方实时数据）`;
          // 复用渲染函数（但不改变主 UI）——这里仅填详情卡片
          // 简化：直接填详情指标
          const tmax = daily.temperature_2m_max?.[0];
          const tmin = daily.temperature_2m_min?.[0];
          const windMax = daily.wind_speed_10m_max?.[0];
          const precipProb = daily.precipitation_probability_max?.[0];
          const precipSum = daily.precipitation_sum?.[0];
          const uvMax = daily.uv_index_max?.[0];

          const hourlyAgg = aggregateHourlyByDate(lastWeatherPayload.hourly);
          const agg = hourlyAgg.get(todayIso) || {};
          const humidityAvg = agg.humidityAvg;
          const visibilityAvg = agg.visibilityAvg;

          dTempRangeEl.textContent = `${fmt(tmin,0)}°C ~ ${fmt(tmax,0)}°C`;
          dWeatherEl.textContent = todayDesc;
          dWindMaxEl.textContent = `${fmt(windMax,0)} km/h`;
          dHumidityAvgEl.textContent = humidityAvg == null ? "-- %" : `${fmt(humidityAvg,0)} %`;
          dPrecipProbEl.textContent = precipProb == null ? "-- %" : `${fmt(precipProb,0)} %`;
          dPrecipSumEl.textContent = precipSum == null ? "-- mm" : `${fmt(precipSum,1)} mm`;
          dUvMaxEl.textContent = uvMax == null ? "--" : fmt(uvMax,1);
          dVisibilityAvgEl.textContent = visibilityAvg == null ? "-- km" : `${fmt(visibilityAvg/1000,1)} km`;
        }
      } else {
        // ✅ 预报展示：主 UI 切到该日预报
        renderForecastDetailsFromPayload(lastWeatherPayload, selectedDayIndex);
      }
    }

    async function fetchWeather() {
      statusEl.textContent = "正在请求 Open-Meteo API…";
      setBadge("● 获取中", "info");

      // ✅ 同时拉 current + daily + hourly（用于 7 天按钮/折线图/湿度日均等）
      const url =
        "https://api.open-meteo.com/v1/forecast" +
        `?latitude=${encodeURIComponent(LAT)}` +
        `&longitude=${encodeURIComponent(LON)}` +
        "&current=temperature_2m,apparent_temperature,weather_code,wind_speed_10m,wind_direction_10m,relative_humidity_2m,pressure_msl,precipitation,cloud_cover,visibility,uv_index" +
        "&hourly=relative_humidity_2m,pressure_msl,precipitation,cloud_cover,visibility,uv_index" +
        "&daily=weather_code,temperature_2m_max,temperature_2m_min,precipitation_probability_max,precipitation_sum,wind_speed_10m_max,uv_index_max" +
        "&forecast_days=7" +
        "&timezone=Asia%2FShanghai";

      const t0 = performance.now();

      try {
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) throw new Error("网络请求失败：" + res.status);
        const data = await res.json();
        lastWeatherPayload = data;

        // ✅ 组装 7 天按钮数据
        const daily = data.daily || {};
        const dates = (daily.time || []).slice(0,7);
        const days = dates.map((iso, i) => {
          const code = daily.weather_code?.[i];
          const desc = weatherText(code);
          return {
            date: iso,
            label: formatCNDate(iso),
            code,
            desc,
            tmax: daily.temperature_2m_max?.[i],
            tmin: daily.temperature_2m_min?.[i]
          };
        });

        buildDayTabs(days);
        buildTrendModel(days);

        // ✅ 图表初始化
        resizeTrendCanvas();
        drawTrend();

        // ✅ 按当前模式渲染（默认实时）
        renderByMode();

        const t1 = performance.now();
        statusEl.textContent = `数据加载成功（耗时 ${Math.round(t1 - t0)} ms）。`;
      } catch (err) {
        console.error(err);
        statusEl.textContent = "获取失败：可能是网络限制或接口不可用。你可以稍后重试。";
        descEl.textContent = "当前无法加载实时天气数据。请检查网络或刷新页面。";
        adviceEl.innerHTML = "<b>出行建议：</b>当前无法生成建议（数据未加载）。";
        setBadge("● 获取失败", "warn");
      }
    }

    function setupAuto() {
      if (timer) clearInterval(timer);
      if (autoRefresh) {
        timer = setInterval(fetchWeather, AUTO_INTERVAL_MS);
        toggleAutoBtn.textContent = "自动刷新：开启";
      } else {
        timer = null;
        toggleAutoBtn.textContent = "自动刷新：关闭";
      }
    }

    refreshBtn.addEventListener("click", fetchWeather);
    toggleAutoBtn.addEventListener("click", () => {
      autoRefresh = !autoRefresh;
      setupAuto();
    });

    backToLiveBtn.addEventListener("click", () => {
      selectedDayIndex = -1;
      updateActiveTab();
      renderByMode();
    });

    el("year").textContent = new Date().getFullYear();

    requestAnimationFrame(() => {
      resizeCanvas();
      setFx("clear", 0);
      step();
    });

    // ✅ 首次加载
    fetchWeather();
    setupAuto();
  </script>

  <!-- ✅ GitHub Pages 发布提示（只在源代码里说明，不影响页面） -->
  <!--
    GitHub Pages 发布要点：
    1) 将此文件命名为 index.html 放到仓库根目录（或 /docs 目录）
    2) 确保 CSS 路径可访问：你当前的 link 是 /mnt/data/...（本地/沙盒路径）
       - 发布到 GitHub Pages 时请把 css 文件放到仓库里，例如 /assets/style.css
       - 然后把 <link rel="stylesheet" href="/mnt/data/xxx.css"> 改为 <link rel="stylesheet" href="./assets/style.css">
    3) 仓库 Settings -> Pages -> Deploy from branch -> 选择 main / (root 或 /docs)
  -->
</body>
</html>
