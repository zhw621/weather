<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>厦门集美区实时天气</title>

  <link rel="stylesheet" href="/mnt/data/18ec03d5-d340-4a72-a26c-c7118b133a3c.css" />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;800&family=JetBrains+Mono:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    .weather-card{
      background: linear-gradient(180deg,#0d1224cc,#0b0f1dcc);
      border:1px solid var(--border);
      border-radius:18px;
      padding:22px;
      box-shadow:var(--shadow);
      position:relative;
      overflow:hidden;
    }

    /* ====== 炫酷动画层 ====== */
    .wx-anim{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index:0;
      opacity:1;
      overflow:hidden;
    }

    #fxCanvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
      opacity:.88;
      filter: saturate(1.2) contrast(1.05);
    }

    .wx-anim::before{
      content:"";
      position:absolute;
      inset:-40% -30%;
      background:
        radial-gradient(circle at 20% 25%, rgba(0,231,255,.22), transparent 55%),
        radial-gradient(circle at 80% 35%, rgba(255,43,214,.18), transparent 58%),
        radial-gradient(circle at 45% 80%, rgba(120,180,255,.12), transparent 60%);
      filter: blur(18px);
      animation: energyFloat 7s ease-in-out infinite alternate;
      opacity:.95;
    }

    .ring{
      position:absolute;
      left:50%;
      top:50%;
      width:560px;
      height:560px;
      transform:translate(-50%,-50%);
      border-radius:50%;
      background: conic-gradient(
        rgba(0,231,255,0),
        rgba(0,231,255,.28),
        rgba(255,43,214,.20),
        rgba(0,231,255,0)
      );
      filter: blur(7px);
      opacity:.35;
      animation: ringSpin 10s linear infinite;
    }

    .mist{
      position:absolute;
      inset:-30% -30%;
      background:
        radial-gradient(360px 240px at 20% 45%, rgba(210,240,255,.18), transparent 62%),
        radial-gradient(460px 300px at 65% 55%, rgba(180,230,255,.14), transparent 64%),
        radial-gradient(420px 280px at 50% 75%, rgba(150,210,255,.12), transparent 64%);
      filter: blur(16px);
      opacity:0;
      animation: mistDrift 8s ease-in-out infinite alternate;
    }

    .flash{
      position:absolute;
      inset:0;
      background: radial-gradient(circle at 55% 32%, rgba(255,255,255,.95), transparent 35%);
      mix-blend-mode: screen;
      opacity:0;
      animation: flash 4.8s infinite;
      display:none;
    }

    .wx-content{ position:relative; z-index:1; }

    .weather-head{
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:6px;
      margin-bottom:16px;
    }

    .place-main{
      width:100%;
      text-align:center;
      font-family:"Orbitron", system-ui;
      font-size:clamp(28px, 4vw, 42px);
      font-weight:800;
      letter-spacing:.12em;
      margin:0 0 6px;
      color:#dff6ff;
      text-shadow: 0 0 12px var(--neon-cyan), 0 0 26px rgba(255,43,214,.22);
    }

    .updated{
      color:var(--muted);
      font-size:.9rem;
      text-align:center;
      margin-top:2px;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 12px;
      border-radius:999px;
      border:1px solid #24406a;
      background:#0b1326cc;
      color:#d1eeff;
      font-weight:700;
      letter-spacing:.02em;
      box-shadow: inset 0 0 0 1px rgba(0,231,255,.10);
      margin-top:6px;
    }

    .big{
      display:flex;
      align-items:baseline;
      justify-content:center;
      gap:10px;
      margin:8px 0 2px;
    }
    .temp{
      font-size: clamp(48px, 6vw, 72px);
      font-weight:800;
      line-height:1;
      font-family:"Orbitron",system-ui;
      text-shadow: 0 0 14px var(--neon-cyan), 0 0 22px rgba(255,43,214,.20);
    }
    .unit{
      color:#bfeaff;
      opacity:.9;
      font-weight:700;
      letter-spacing:.06em;
    }

    /* ✅ 新增：温度范围显示行 */
    .range-line{
      text-align:center;
      color:#9fbbe0;
      font-family:"JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:.92rem;
      margin-bottom:8px;
      min-height: 1.2em;
      opacity:.95;
      text-shadow: 0 0 10px rgba(0,231,255,.10);
    }

    .desc{
      color:var(--muted);
      margin:6px 0 10px;
      line-height:1.6;
      text-align:center;
    }

    .advice{
      margin: 10px 0 18px;
      padding:12px 14px;
      border-radius:14px;
      border:1px solid #24406a;
      background:#0b1326cc;
      box-shadow: inset 0 0 0 1px rgba(0,231,255,.10);
      color:#cfefff;
      line-height:1.65;
    }
    .advice b{
      font-family:"Orbitron",system-ui;
      letter-spacing:.06em;
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap:12px;
    }
    @media (max-width:560px){ .grid{ grid-template-columns: 1fr; } }

    .metric{
      padding:14px 14px;
      border-radius:14px;
      border:1px solid #24406a;
      background:#0b1326cc;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      transition: transform .15s ease, border-color .15s ease, background .15s ease;
    }
    .metric:hover{
      transform: translateY(-2px);
      border-color:#4ac8ff;
      background:#0e1a33;
    }
    .metric .k{ color:#8db3cc; font-size:.9rem; }
    .metric .v{ color:#d1eeff; font-weight:800; letter-spacing:.02em; }

    .actions{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      margin-top:16px;
      justify-content:center;
    }
    .btn{
      cursor:pointer;
      border:1px solid #24406a;
      background:#0b1326cc;
      color:#d1eeff;
      border-radius:12px;
      padding:10px 14px;
      font-weight:800;
      letter-spacing:.03em;
      transition:.15s;
      box-shadow: inset 0 0 0 1px rgba(0,231,255,.10);
    }
    .btn:hover{ transform: translateY(-2px); border-color:#4ac8ff; background:#0e1a33; }
    .btn:active{ transform: translateY(0); }

    .status{
      margin-top:10px;
      color:#9fb5c6;
      font-size:.9rem;
      text-align:center;
    }

    @keyframes energyFloat{
      from{ transform: translate(-2%, -1%) scale(1); }
      to  { transform: translate(2%, 1%) scale(1.06); }
    }
    @keyframes ringSpin{
      from{ transform:translate(-50%,-50%) rotate(0deg); }
      to  { transform:translate(-50%,-50%) rotate(360deg); }
    }
    @keyframes mistDrift{
      from{ transform: translateX(-4%); }
      to  { transform: translateX(4%); }
    }
    @keyframes flash{
      0%,92%,100%{ opacity:0; }
      93%{ opacity:.92; }
      95%{ opacity:.20; }
      97%{ opacity:.98; }
    }

    .wx-clear .ring{ opacity:.55; }
    .wx-clouds .ring{ opacity:.36; }
    .wx-overcast .ring{ opacity:.20; filter: blur(9px); }
    .wx-rain .ring{ opacity:.25; filter: blur(10px); }
    .wx-snow .ring{ opacity:.22; filter: blur(11px); }
    .wx-fog  .ring{ opacity:.14; filter: blur(12px); }
    .wx-thunder .ring{ opacity:.18; filter: blur(12px); }

    .wx-clouds .mist{ opacity:.58; }
    .wx-overcast .mist{ opacity:.72; }
    .wx-thunder .mist{ opacity:.82; }

    .wx-thunder .flash{ display:block; }

    /* =========================================================
       ✅ 新增功能 1：未来 7 天按钮 + 详情面板（暗黑科技风）
       ========================================================= */
    .forecast-wrap{
      margin-top:14px;
      padding:14px 14px 12px;
      border-radius:16px;
      border:1px solid #24406a;
      background:#0b1326cc;
      box-shadow: inset 0 0 0 1px rgba(0,231,255,.10);
    }
    .forecast-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .forecast-title h2{
      margin:0;
      font-size:1rem;
      color:#d1eeff;
      letter-spacing:.06em;
      font-family:"Orbitron",system-ui;
      text-shadow: 0 0 12px rgba(0,231,255,.14);
    }
    .mini-btn{
      cursor:pointer;
      border:1px solid #24406a;
      background:#091126cc;
      color:#d1eeff;
      border-radius:10px;
      padding:8px 10px;
      font-weight:800;
      letter-spacing:.03em;
      transition:.15s;
      box-shadow: inset 0 0 0 1px rgba(0,231,255,.10);
      font-size:.92rem;
    }
    .mini-btn:hover{ transform: translateY(-2px); border-color:#4ac8ff; background:#0e1a33; }
    .mini-btn:active{ transform: translateY(0); }

    .day-buttons{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      justify-content:center;
      margin: 8px 0 10px;
    }
    .day-btn{
      cursor:pointer;
      border:1px solid #24406a;
      background:#091126cc;
      color:#d1eeff;
      border-radius:12px;
      padding:10px 12px;
      font-weight:800;
      letter-spacing:.02em;
      transition:.15s;
      box-shadow: inset 0 0 0 1px rgba(0,231,255,.10);
      display:flex;
      align-items:center;
      gap:8px;
      white-space:nowrap;
      user-select:none;
      font-size:.92rem;
    }
    .day-btn:hover{
      transform: translateY(-2px);
      border-color:#4ac8ff;
      background:#0e1a33;
    }
    .day-btn.active{
      border-color: rgba(0,231,255,.85);
      background: linear-gradient(180deg, rgba(0,231,255,.10), rgba(255,43,214,.08));
      box-shadow:
        0 0 22px rgba(0,231,255,.20),
        inset 0 0 0 1px rgba(0,231,255,.18);
    }
    .day-dot{
      width:8px;height:8px;border-radius:999px;
      background: rgba(0,231,255,.85);
      box-shadow: 0 0 12px rgba(0,231,255,.30);
      flex: 0 0 auto;
    }
    .day-btn.active .day-dot{
      background: rgba(255,43,214,.92);
      box-shadow: 0 0 14px rgba(255,43,214,.32);
    }

    /* =========================================================
       ✅ 新增功能 2：7 天折线图（霓虹暗黑风 + Hover 提示）
       ========================================================= */
    .trend-card{
      margin-top:16px;
      border-radius:18px;
      border:1px solid #24406a;
      background:#0b1326cc;
      box-shadow: inset 0 0 0 1px rgba(0,231,255,.10), var(--shadow);
      padding:14px 14px 10px;
      position:relative;
      overflow:hidden;
    }
    .trend-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .trend-head h2{
      margin:0;
      font-size:1rem;
      color:#d1eeff;
      letter-spacing:.06em;
      font-family:"Orbitron",system-ui;
      text-shadow: 0 0 12px rgba(0,231,255,.14);
    }
    .legend{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
      font-size:.86rem;
      color:#9fb5c6;
      user-select:none;
    }
    .lg{
      display:flex; align-items:center; gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid #24406a;
      background:#091126cc;
      box-shadow: inset 0 0 0 1px rgba(0,231,255,.08);
    }
    .swatch{
      width:14px; height:3px; border-radius:99px;
      background: rgba(0,231,255,.85);
      box-shadow: 0 0 12px rgba(0,231,255,.22);
    }
    .swatch.min{
      background: rgba(255,43,214,.75);
      box-shadow: 0 0 12px rgba(255,43,214,.20);
    }

    .trend-canvas-wrap{
      position:relative;
      border-radius:14px;
      border:1px solid #24406a;
      background: linear-gradient(180deg, rgba(10,18,40,.55), rgba(9,14,30,.55));
      overflow:hidden;
    }
    #trendCanvas{
      width:100%;
      height:240px;
      display:block;
    }
    @media (max-width:560px){
      #trendCanvas{ height: 210px; }
    }

    .trend-tip{
      position:absolute;
      pointer-events:none;
      z-index:5;
      transform: translate(-50%, -110%);
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(0,231,255,.35);
      background: rgba(7, 12, 28, .88);
      box-shadow:
        0 0 24px rgba(0,231,255,.16),
        inset 0 0 0 1px rgba(0,231,255,.12);
      color:#d1eeff;
      font-size:.88rem;
      line-height:1.45;
      display:none;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      min-width: 160px;
    }
    .trend-tip b{
      font-family:"Orbitron",system-ui;
      letter-spacing:.05em;
    }
    .trend-tip .row{
      display:flex;
      justify-content:space-between;
      gap:12px;
      margin-top:4px;
      color:#bfeaff;
      font-family:"JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    .trend-tip .hi{ color: rgba(0,231,255,.95); text-shadow: 0 0 10px rgba(0,231,255,.18); }
    .trend-tip .lo{ color: rgba(255,43,214,.90); text-shadow: 0 0 10px rgba(255,43,214,.16); }

  </style>
</head>

<body>
  <div class="bg fx-grid"></div>
  <div class="bg fx-noise"></div>
  <div class="bg fx-scanline"></div>

  <main class="container">
    <section class="hero-card">
      <div class="weather-card" aria-live="polite">
        <div class="wx-anim wx-clear" id="wxAnim">
          <canvas id="fxCanvas"></canvas>
          <div class="ring"></div>
          <div class="mist"></div>
          <div class="flash"></div>
        </div>

        <div class="wx-content">
          <div class="weather-head">
            <h1 class="place-main">厦门 · 集美区</h1>
            <div class="updated" id="updatedText">正在获取最新天气…</div>
            <div class="pill" id="badge">● 加载中</div>
          </div>

          <div class="big">
            <div class="temp" id="temp">--</div>
            <div class="unit">°C</div>
          </div>

          <!-- ✅ 新增：温度范围（预报日显示，高/低；实时默认空） -->
          <div class="range-line" id="rangeLine"></div>

          <div class="desc" id="desc">请稍候，正在加载实时天气信息。</div>

          <div class="advice" id="advice"><b>出行建议：</b>正在生成建议…</div>

          <!-- ✅ 新增：未来 7 天日期切换模块 -->
          <div class="forecast-wrap" id="forecastWrap" aria-label="未来七天天气预报">
            <div class="forecast-title">
              <h2>未来 7 天 · 日期切换</h2>
              <button class="mini-btn" id="backToNowBtn" type="button" title="返回实时天气">返回实时</button>
            </div>
            <div class="day-buttons" id="dayButtons">
              <!-- JS 动态生成 7 天按钮 -->
            </div>
            <div class="status" id="forecastStatus">预报模块加载中…</div>
          </div>

          <div class="grid" id="metrics">
            <div class="metric"><span class="k">体感温度</span><span class="v" id="apparent">-- °C</span></div>
            <div class="metric"><span class="k">风速</span><span class="v" id="wind">-- km/h</span></div>
            <div class="metric"><span class="k">湿度</span><span class="v" id="humidity">-- %</span></div>
            <div class="metric"><span class="k">气压</span><span class="v" id="pressure">-- hPa</span></div>
            <div class="metric"><span class="k">降水</span><span class="v" id="precip">-- mm</span></div>
            <div class="metric"><span class="k">云量</span><span class="v" id="cloud">-- %</span></div>
            <div class="metric"><span class="k">能见度</span><span class="v" id="visibility">-- km</span></div>
            <div class="metric"><span class="k">UV 指数</span><span class="v" id="uv">--</span></div>

            <!-- ✅ 新增：预报相关核心指标（在切换到预报日时会填充；实时也可显示为 --） -->
            <div class="metric"><span class="k">降水概率</span><span class="v" id="pop">-- %</span></div>
            <div class="metric"><span class="k">最高/最低</span><span class="v" id="hiLo">-- / -- °C</span></div>
          </div>

          <div class="actions">
            <button class="btn" id="refreshBtn" type="button">手动刷新</button>
            <button class="btn" id="toggleAutoBtn" type="button">自动刷新：开启</button>
          </div>

          <div class="status" id="status"></div>

          <!-- ✅ 新增：7 天折线图（放在网页底部 footer 上方） -->
          <div class="trend-card" id="trendCard" aria-label="未来七天温度折线图">
            <div class="trend-head">
              <h2>未来 7 天 · 温度趋势</h2>
              <div class="legend">
                <div class="lg"><span class="swatch"></span><span>最高气温</span></div>
                <div class="lg"><span class="swatch min"></span><span>最低气温</span></div>
              </div>
            </div>

            <div class="trend-canvas-wrap" id="trendWrap">
              <canvas id="trendCanvas"></canvas>
              <div class="trend-tip" id="trendTip"></div>
            </div>
          </div>

        </div>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    © <span id="year"></span> Xiamen Jimei Weather · Cyber UI
  </footer>

  <script>
    const LAT = 24.58;
    const LON = 118.10;

    let autoRefresh = true;
    let timer = null;
    const AUTO_INTERVAL_MS = 5 * 60 * 1000;

    const el = (id) => document.getElementById(id);
    const tempEl = el("temp");
    const rangeLineEl = el("rangeLine");
    const descEl = el("desc");
    const badgeEl = el("badge");
    const updatedEl = el("updatedText");
    const statusEl = el("status");
    const adviceEl = el("advice");
    const animEl = el("wxAnim");

    const apparentEl = el("apparent");
    const windEl = el("wind");
    const humidityEl = el("humidity");
    const pressureEl = el("pressure");
    const precipEl = el("precip");
    const cloudEl = el("cloud");
    const visibilityEl = el("visibility");
    const uvEl = el("uv");
    const popEl = el("pop");
    const hiLoEl = el("hiLo");

    const refreshBtn = el("refreshBtn");
    const toggleAutoBtn = el("toggleAutoBtn");

    // ✅ 新增 DOM
    const dayButtonsEl = el("dayButtons");
    const forecastStatusEl = el("forecastStatus");
    const backToNowBtn = el("backToNowBtn");

    // ✅ 折线图 DOM
    const trendCanvas = el("trendCanvas");
    const trendWrap = el("trendWrap");
    const trendTip = el("trendTip");

    // ✅ 新增：全局缓存（当前 + 7 天）
    let weatherCache = {
      current: null,
      daily: null,
      hourly: null
    };

    // ✅ 新增：视图状态（默认实时）
    let viewMode = "current"; // "current" | "daily"
    let selectedDayIndex = -1;

    function weatherText(code) {
      const map = {
        0: "晴朗", 1: "大致晴", 2: "多云", 3: "阴天",
        45: "雾", 48: "雾凇",
        51: "毛毛雨（弱）", 53: "毛毛雨（中）", 55: "毛毛雨（强）",
        56: "冻毛毛雨（弱）", 57: "冻毛毛雨（强）",
        61: "小雨", 63: "中雨", 65: "大雨",
        66: "冻雨（弱）", 67: "冻雨（强）",
        71: "小雪", 73: "中雪", 75: "大雪", 77: "雪粒",
        80: "阵雨（弱）", 81: "阵雨（中）", 82: "阵雨（强）",
        85: "阵雪（弱）", 86: "阵雪（强）",
        95: "雷暴", 96: "雷暴伴随冰雹（弱）", 99: "雷暴伴随冰雹（强）",
      };
      return map[code] ?? `未知天气（code ${code}）`;
    }

    function windDirText(deg) {
      if (deg == null || Number.isNaN(deg)) return "";
      const dirs = ["北", "东北", "东", "东南", "南", "西南", "西", "西北"];
      const i = Math.round(deg / 45) % 8;
      return dirs[i];
    }

    function fmt(n, digits = 0) {
      if (n == null || Number.isNaN(n)) return "--";
      return Number(n).toFixed(digits);
    }

    function setBadge(text, mode = "ok") {
      badgeEl.textContent = text;
      if (mode === "ok") {
        badgeEl.style.borderColor = "#24406a";
        badgeEl.style.boxShadow = "inset 0 0 0 1px rgba(0,231,255,.10)";
      } else if (mode === "warn") {
        badgeEl.style.borderColor = "#ff2bd655";
        badgeEl.style.boxShadow = "0 0 18px rgba(255,43,214,.22)";
      } else {
        badgeEl.style.borderColor = "#8a6bff55";
        badgeEl.style.boxShadow = "0 0 18px rgba(138,107,255,.22)";
      }
    }

    /* ========= Canvas 粒子特效引擎（按天气切换） ========= */
    const canvas = document.getElementById("fxCanvas");
    const ctx = canvas.getContext("2d");

    let fxMode = "clear";
    let fxWind = 0;
    let fxIntensity = 1;
    let dpr = Math.max(1, window.devicePixelRatio || 1);

    const particles = [];
    const sparks = [];

    function resizeCanvas(){
      const r = canvas.getBoundingClientRect();
      const w = Math.max(1, r.width);
      const h = Math.max(1, r.height);
      canvas.width  = Math.round(w * dpr);
      canvas.height = Math.round(h * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    window.addEventListener("resize", () => {
      resizeCanvas();
      resizeTrendCanvas();
    });

    function rand(a,b){ return a + Math.random()*(b-a); }

    function spawn(){
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;
      const count = Math.floor(7 * fxIntensity);

      if (fxMode === "rain" || fxMode === "thunder"){
        for (let i=0;i<count*3;i++){
          particles.push({
            x: rand(-20, w+20),
            y: rand(-h, 0),
            vx: rand(0.6, 1.6) + fxWind*0.03,
            vy: rand(9, 16) + fxIntensity*2.0,
            len: rand(14, 28),
            a: rand(0.14, 0.32)
          });
        }
      } else if (fxMode === "snow"){
        for (let i=0;i<count*2;i++){
          particles.push({
            x: rand(-20, w+20),
            y: rand(-h, 0),
            vx: rand(-0.7, 0.9) + fxWind*0.02,
            vy: rand(1.1, 2.8) + fxIntensity*0.25,
            r: rand(0.8, 2.4),
            tw: rand(0.004, 0.012),
            t: rand(0, 999)
          });
        }
      } else if (fxMode === "fog" || fxMode === "clouds" || fxMode === "overcast"){
        for (let i=0;i<count;i++){
          particles.push({
            x: rand(-80, w+80),
            y: rand(0, h),
            vx: rand(0.18, 0.55) + fxWind*0.01,
            vy: rand(-0.05, 0.05),
            r: rand(70, 160),
            a: rand(0.03, 0.085)
          });
        }
      } else {
        for (let i=0;i<count;i++){
          particles.push({
            x: rand(0, w),
            y: rand(0, h),
            vx: rand(-0.14, 0.14),
            vy: rand(-0.12, 0.12),
            r: rand(0.6, 1.8),
            a: rand(0.10, 0.24),
            tw: rand(0.006, 0.016),
            t: rand(0, 999)
          });
        }
      }
    }

    function lightning(){
      if (fxMode !== "thunder") return;
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;
      const x0 = rand(w*0.35, w*0.7);
      const y0 = rand(0, h*0.25);

      for (let i=0;i<22;i++){
        sparks.push({
          x: x0 + rand(-12,12),
          y: y0 + rand(-8,8),
          vx: rand(-3.0,3.0),
          vy: rand(0.8,5.0),
          life: rand(14, 28),
          a: rand(0.25, 0.65)
        });
      }
    }

    let lastLightning = 0;

    function step(){
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;

      ctx.clearRect(0,0,w,h);

      if (particles.length < 420) spawn();

      if (fxMode === "thunder"){
        const now = performance.now();
        if (now - lastLightning > rand(1100, 2400)){
          lastLightning = now;
          lightning();
        }
      }

      for (let i=particles.length-1;i>=0;i--){
        const p = particles[i];

        if (fxMode === "rain" || fxMode === "thunder"){
          p.x += p.vx;
          p.y += p.vy;

          ctx.globalAlpha = p.a;
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(p.x - p.vx*2.0, p.y - p.len);
          ctx.strokeStyle = "rgba(210,245,255,0.95)";
          ctx.lineWidth = 1;
          ctx.stroke();

          if (p.y > h+40 || p.x < -60 || p.x > w+60) particles.splice(i,1);
        }
        else if (fxMode === "snow"){
          p.t += 1;
          const tw = (Math.sin(p.t * p.tw) + 1) * 0.5;
          p.x += p.vx + Math.sin(p.t*0.02)*0.18;
          p.y += p.vy;

          ctx.globalAlpha = 0.12 + tw * 0.38;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
          ctx.fillStyle = "rgba(240,252,255,0.95)";
          ctx.fill();

          if (p.y > h+24) particles.splice(i,1);
        }
        else if (fxMode === "fog" || fxMode === "clouds" || fxMode === "overcast"){
          p.x += p.vx;
          p.y += p.vy;

          ctx.globalAlpha = p.a;
          const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r);
          g.addColorStop(0, "rgba(220,245,255,0.55)");
          g.addColorStop(1, "rgba(220,245,255,0)");
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
          ctx.fill();

          if (p.x > w+160) p.x = -160;
        }
        else {
          p.t += 1;
          const tw = (Math.sin(p.t * p.tw) + 1) * 0.5;
          p.x += p.vx;
          p.y += p.vy;

          if (p.x < 0) p.x = w;
          if (p.x > w) p.x = 0;
          if (p.y < 0) p.y = h;
          if (p.y > h) p.y = 0;

          ctx.globalAlpha = p.a + tw*0.22;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
          ctx.fillStyle = "rgba(190,245,255,0.95)";
          ctx.fill();
        }
      }

      for (let i=sparks.length-1;i>=0;i--){
        const s = sparks[i];
        s.x += s.vx;
        s.y += s.vy;
        s.vy += 0.12;
        s.life -= 1;

        ctx.globalAlpha = s.a * Math.max(0, s.life/28);
        ctx.beginPath();
        ctx.arc(s.x, s.y, 1.6, 0, Math.PI*2);
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fill();

        if (s.life <= 0) sparks.splice(i,1);
      }

      requestAnimationFrame(step);
    }

    function setFx(mode, windKmh){
      fxMode = mode;
      fxWind = windKmh ?? 0;

      if (mode === "thunder") fxIntensity = 2.7;
      else if (mode === "rain") fxIntensity = 2.1;
      else if (mode === "snow") fxIntensity = 1.7;
      else if (mode === "fog") fxIntensity = 1.9;
      else if (mode === "overcast") fxIntensity = 1.55;
      else if (mode === "clouds") fxIntensity = 1.35;
      else fxIntensity = 1.15;

      particles.length = 0;
      sparks.length = 0;
      spawn();
    }

    function animClassByCode(code){
      if ([95,96,99].includes(code)) return "wx-thunder";
      if ([45,48].includes(code)) return "wx-fog";
      if ([71,73,75,77,85,86].includes(code)) return "wx-snow";
      if ([51,53,55,56,57,61,63,65,66,67,80,81,82].includes(code)) return "wx-rain";
      if (code === 3) return "wx-overcast";
      if (code === 2) return "wx-clouds";
      if (code === 0 || code === 1) return "wx-clear";
      return "wx-clouds";
    }
    function fxModeByClass(cls){
      if (cls === "wx-thunder") return "thunder";
      if (cls === "wx-fog") return "fog";
      if (cls === "wx-snow") return "snow";
      if (cls === "wx-rain") return "rain";
      if (cls === "wx-overcast") return "overcast";
      if (cls === "wx-clouds") return "clouds";
      return "clear";
    }

    function setAnim(code, wind){
      const cls = animClassByCode(code);
      animEl.className = `wx-anim ${cls}`;
      resizeCanvas();
      setFx(fxModeByClass(cls), wind);
    }

    function makeAdvice({ code, temp, wind, precip, uv, visibilityKm }){
      const tips = [];

      if ([95,96,99].includes(code)) tips.push("尽量避免空旷地/海边停留，注意雷电与突发强降雨。");
      if ([45,48].includes(code)) tips.push("雾较明显：慢行、开雾灯，骑行注意安全。");
      if ([71,73,75,77,85,86].includes(code)) tips.push("路面可能湿滑：建议防滑鞋，谨慎驾驶。");
      if ([51,53,55,56,57,61,63,65,66,67,80,81,82].includes(code)) tips.push("建议随身带伞/雨衣，鞋子尽量防水。");

      if (temp != null) {
        if (temp >= 30) tips.push("体感偏热：轻薄透气，及时补水。");
        else if (temp <= 12) tips.push("体感偏凉：加外套，早晚保暖。");
        else tips.push("体感舒适：适合户外活动。");
      }

      if (wind != null) {
        if (wind >= 35) tips.push("风较大：减少骑行/高处停留，注意落物。");
        else if (wind >= 20) tips.push("有风：可备轻薄外套。");
      }

      if (uv != null) {
        if (uv >= 8) tips.push("UV 很强：防晒霜+帽子/墨镜，尽量避开正午暴晒。");
        else if (uv >= 5) tips.push("UV 较强：建议适度防晒。");
      }

      if (visibilityKm != null && visibilityKm < 3) tips.push("能见度较低：注意车距，避免急刹。");
      if (precip != null && precip >= 2) tips.push("降水偏多：尽量走有遮挡路线，注意积水。");

      const text = tips.length ? tips.join(" ") : "天气信息不足，建议关注路况并备好雨具/外套。";
      return `<b>出行建议：</b>${text}`;
    }

    // ✅ 找 hourly.time 里“最接近 current.time”的索引（兜底用）
    function findClosestTimeIndex(times, targetIso){
      if (!Array.isArray(times) || !times.length || !targetIso) return -1;
      const target = Date.parse(targetIso);
      if (!Number.isFinite(target)) return -1;

      let best = 0;
      let bestDiff = Infinity;
      for (let i=0;i<times.length;i++){
        const t = Date.parse(times[i]);
        if (!Number.isFinite(t)) continue;
        const diff = Math.abs(t - target);
        if (diff < bestDiff){
          bestDiff = diff;
          best = i;
        }
      }
      return bestDiff === Infinity ? -1 : best;
    }

    // ✅ 日期格式：1月5日
    function fmtZhMD(isoDate){
      // isoDate: YYYY-MM-DD
      const [y,m,d] = String(isoDate).split("-").map(Number);
      if (!y || !m || !d) return isoDate;
      return `${m}月${d}日`;
    }

    // ✅ 从 hourly 数据计算某天平均湿度（%）
    function calcDailyAvgHumidity(dayIso){
      const hourly = weatherCache.hourly || {};
      const times = hourly.time || [];
      const hum = hourly.relative_humidity_2m || [];
      let sum = 0, cnt = 0;
      for (let i=0;i<times.length;i++){
        if (typeof times[i] === "string" && times[i].startsWith(dayIso)){
          const v = hum[i];
          if (v != null && Number.isFinite(Number(v))){
            sum += Number(v);
            cnt += 1;
          }
        }
      }
      if (!cnt) return null;
      return sum / cnt;
    }

    // ✅ 新增：渲染 7 天按钮
    function renderDayButtons(){
      const daily = weatherCache.daily;
      if (!daily?.time?.length){
        dayButtonsEl.innerHTML = "";
        forecastStatusEl.textContent = "预报数据不足（接口未返回 daily）。";
        return;
      }

      const times = daily.time.slice(0,7);
      dayButtonsEl.innerHTML = times.map((t, idx) => {
        const code = daily.weather_code?.[idx];
        const brief = weatherText(code).replace(/（.*?）/g,""); // 简化一点
        const md = fmtZhMD(t);
        return `
          <button class="day-btn" type="button" data-idx="${idx}" aria-label="${md} ${brief}">
            <span class="day-dot"></span>
            <span>${md} · ${brief}</span>
          </button>
        `;
      }).join("");

      forecastStatusEl.textContent = "点击日期按钮查看详细预报（默认展示实时天气）。";

      // 绑定点击
      [...dayButtonsEl.querySelectorAll(".day-btn")].forEach(btn => {
        btn.addEventListener("click", () => {
          const idx = Number(btn.dataset.idx);
          selectDaily(idx);
        });
      });

      // ✅ 默认不激活（保持实时模式）
      clearActiveButtons();
    }

    function clearActiveButtons(){
      [...dayButtonsEl.querySelectorAll(".day-btn")].forEach(b => b.classList.remove("active"));
    }

    function setActiveButton(idx){
      clearActiveButtons();
      const btn = dayButtonsEl.querySelector(`.day-btn[data-idx="${idx}"]`);
      if (btn) btn.classList.add("active");
    }

    // ✅ 切换到某一天的预报展示（不破坏 Canvas：只切换 setAnim）
    function selectDaily(idx){
      const daily = weatherCache.daily;
      if (!daily?.time?.length) return;
      if (idx < 0 || idx >= Math.min(7, daily.time.length)) return;

      viewMode = "daily";
      selectedDayIndex = idx;
      setActiveButton(idx);

      const dayIso = daily.time[idx];
      const code = daily.weather_code?.[idx];
      const text = weatherText(code);

      const tmax = daily.temperature_2m_max?.[idx];
      const tmin = daily.temperature_2m_min?.[idx];
      const windMax = daily.wind_speed_10m_max?.[idx];
      const windDir = daily.wind_direction_10m_dominant?.[idx];
      const popMax = daily.precipitation_probability_max?.[idx];
      const precipSum = daily.precipitation_sum?.[idx];

      // 湿度：用 hourly 平均值补齐（若有）
      const humAvg = calcDailyAvgHumidity(dayIso);

      // ✅ 让粒子特效随预报日变化（但不重排布局）
      setAnim(code, windMax);

      // ✅ 顶部主温度：用当天最高温；下方显示高/低范围
      tempEl.textContent = fmt(tmax, 0);
      rangeLineEl.textContent = `预报温度：最高 ${fmt(tmax,0)}° / 最低 ${fmt(tmin,0)}°`;

      // ✅ 描述 + badge + 更新时间文案改为“预报日期”
      descEl.textContent = `${fmtZhMD(dayIso)} · ${text} · 温度范围 ${fmt(tmin,0)}°C ~ ${fmt(tmax,0)}°C。`;
      updatedEl.textContent = `预报日期：${fmtZhMD(dayIso)}（${dayIso}）`;
      setBadge(`● 预报：${text}`, "ok");

      // ✅ 指标区：优先展示预报关键项（实时项给出合理兜底）
      apparentEl.textContent = `-- °C`;
      windEl.textContent = `${fmt(windMax, 0)} km/h ${windDirText(windDir)}`;
      humidityEl.textContent = humAvg == null ? "-- %" : `${fmt(humAvg,0)} %`;
      pressureEl.textContent = `-- hPa`;
      precipEl.textContent = `${fmt(precipSum, 1)} mm`;
      cloudEl.textContent = `-- %`;
      visibilityEl.textContent = `-- km`;
      uvEl.textContent = `--`;

      popEl.textContent = popMax == null ? "-- %" : `${fmt(popMax,0)} %`;
      hiLoEl.textContent = `${fmt(tmax,0)} / ${fmt(tmin,0)} °C`;

      // ✅ 建议：用当天“最高温/最大风/降水”生成
      adviceEl.innerHTML = makeAdvice({
        code,
        temp: tmax,
        wind: windMax,
        precip: precipSum,
        uv: null,
        visibilityKm: null
      });

      statusEl.textContent = "已切换到未来预报日（实时自动刷新仍在后台更新数据）。";
    }

    // ✅ 返回实时模式
    function backToCurrent(){
      viewMode = "current";
      selectedDayIndex = -1;
      clearActiveButtons();
      rangeLineEl.textContent = ""; // 实时默认不显示范围
      // 直接用缓存 current 重刷 UI（如果没有则重新 fetch）
      if (weatherCache.current) {
        renderCurrentFromCache();
      } else {
        fetchWeather();
      }
    }
    backToNowBtn.addEventListener("click", backToCurrent);

    // ✅ 将实时数据渲染为 UI（供返回实时/自动刷新使用）
    function renderCurrentFromCache(){
      const data = weatherCache;
      const cur = data.current || {};
      const hourly = data.hourly || {};

      const temp = cur.temperature_2m;
      const app = cur.apparent_temperature;
      const code = cur.weather_code;
      const wind = cur.wind_speed_10m;
      const windDir = cur.wind_direction_10m;
      const time = cur.time;

      let humidity = cur.relative_humidity_2m;
      let pressure = cur.pressure_msl;
      let precip = cur.precipitation;
      let cloud = cur.cloud_cover;
      let visibility = cur.visibility;
      let uv = cur.uv_index;

      // 兜底：用 hourly 最近时间点补齐
      const times = hourly.time || [];
      const idx = findClosestTimeIndex(times, time);

      if (humidity == null && idx >= 0) humidity = hourly.relative_humidity_2m?.[idx];
      if (pressure == null && idx >= 0) pressure = hourly.pressure_msl?.[idx];
      if (precip == null && idx >= 0) precip = hourly.precipitation?.[idx];
      if (cloud == null && idx >= 0) cloud = hourly.cloud_cover?.[idx];
      if (visibility == null && idx >= 0) visibility = hourly.visibility?.[idx];
      if (uv == null && idx >= 0) uv = hourly.uv_index?.[idx];

      setAnim(code, wind);

      tempEl.textContent = fmt(temp, 0);
      apparentEl.textContent = `${fmt(app, 0)} °C`;
      windEl.textContent = `${fmt(wind, 0)} km/h ${windDirText(windDir)}`;

      humidityEl.textContent = `${fmt(humidity, 0)} %`;
      pressureEl.textContent = `${fmt(pressure, 0)} hPa`;
      precipEl.textContent = `${fmt(precip, 1)} mm`;
      cloudEl.textContent = `${fmt(cloud, 0)} %`;
      visibilityEl.textContent = visibility == null ? "-- km" : `${fmt(visibility / 1000, 1)} km`;
      uvEl.textContent = fmt(uv, 1);

      // ✅ 预报相关字段在实时模式下可显示为 --（或用今天的 daily 补充）
      popEl.textContent = "-- %";
      hiLoEl.textContent = "-- / -- °C";

      const text = weatherText(code);
      descEl.textContent = `${text} · 当前温度 ${fmt(temp, 0)}°C，体感 ${fmt(app, 0)}°C。`;

      const visibilityKm = visibility == null ? null : (visibility / 1000);
      adviceEl.innerHTML = makeAdvice({ code, temp, wind, precip, uv, visibilityKm });

      const dt = time ? new Date(time) : new Date();
      updatedEl.textContent = `更新时间：${dt.toLocaleString("zh-CN", { hour12: false })}`;

      setBadge(`● ${text}`, "ok");
    }

    async function fetchWeather() {
      statusEl.textContent = "正在请求 Open-Meteo API…";
      setBadge("● 获取中", "info");

      // ✅ 新增 daily= 未来 7 天预报数据（并保留原有 current/hourly）
      const url =
        "https://api.open-meteo.com/v1/forecast" +
        `?latitude=${encodeURIComponent(LAT)}` +
        `&longitude=${encodeURIComponent(LON)}` +
        "&current=temperature_2m,apparent_temperature,weather_code,wind_speed_10m,wind_direction_10m,relative_humidity_2m,pressure_msl,precipitation,cloud_cover,visibility,uv_index" +
        "&hourly=relative_humidity_2m,pressure_msl,precipitation,cloud_cover,visibility,uv_index" +
        "&daily=weather_code,temperature_2m_max,temperature_2m_min,precipitation_probability_max,precipitation_sum,wind_speed_10m_max,wind_direction_10m_dominant" +
        "&forecast_days=7" +
        "&timezone=Asia%2FShanghai";

      const t0 = performance.now();

      try {
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) throw new Error("网络请求失败：" + res.status);
        const data = await res.json();

        // ✅ 缓存
        weatherCache.current = data.current || null;
        weatherCache.hourly = data.hourly || null;
        weatherCache.daily = data.daily || null;

        // ✅ 渲染 7 天按钮 + 折线图
        renderDayButtons();
        drawTrendChartFromDaily();

        // ✅ 如果当前处于“预报日”，保持选中并刷新该日数据；否则刷新实时
        if (viewMode === "daily" && selectedDayIndex >= 0) {
          selectDaily(selectedDayIndex);
        } else {
          viewMode = "current";
          selectedDayIndex = -1;
          rangeLineEl.textContent = "";
          renderCurrentFromCache();
        }

        const t1 = performance.now();
        statusEl.textContent = `数据加载成功（耗时 ${Math.round(t1 - t0)} ms）。`;
        forecastStatusEl.textContent = "预报已更新：可点击日期查看详细信息，也可返回实时。";
      } catch (err) {
        console.error(err);
        statusEl.textContent = "获取失败：可能是网络限制或接口不可用。你可以稍后重试。";
        descEl.textContent = "当前无法加载实时天气数据。请检查网络或刷新页面。";
        adviceEl.innerHTML = "<b>出行建议：</b>当前无法生成建议（数据未加载）。";
        setBadge("● 获取失败", "warn");
        forecastStatusEl.textContent = "预报模块不可用（接口失败）。";
      }
    }

    function setupAuto() {
      if (timer) clearInterval(timer);
      if (autoRefresh) {
        timer = setInterval(fetchWeather, AUTO_INTERVAL_MS);
        toggleAutoBtn.textContent = "自动刷新：开启";
      } else {
        timer = null;
        toggleAutoBtn.textContent = "自动刷新：关闭";
      }
    }

    refreshBtn.addEventListener("click", fetchWeather);
    toggleAutoBtn.addEventListener("click", () => {
      autoRefresh = !autoRefresh;
      setupAuto();
    });

    el("year").textContent = new Date().getFullYear();

    requestAnimationFrame(() => {
      resizeCanvas();
      setFx("clear", 0);
      step();
    });

    /* =========================================================
       ✅ 7 天折线图（Canvas）实现：最高/最低两条线 + hover tooltip
       ========================================================= */
    let trendState = {
      points: [], // {x,yHi,yLo,dayIso,hi,lo,code}
      hi: [],
      lo: [],
      days: [],
      codes: []
    };

    function resizeTrendCanvas(){
      const rect = trendWrap.getBoundingClientRect();
      const w = Math.max(1, rect.width);
      const h = Math.max(1, trendCanvas.getBoundingClientRect().height);
      const dpr2 = Math.max(1, window.devicePixelRatio || 1);
      trendCanvas.width = Math.round(w * dpr2);
      trendCanvas.height = Math.round(h * dpr2);
      const tctx = trendCanvas.getContext("2d");
      tctx.setTransform(dpr2,0,0,dpr2,0,0);
      // 重新绘制
      drawTrendChart();
    }

    function drawTrendChartFromDaily(){
      const daily = weatherCache.daily;
      if (!daily?.time?.length) return;

      const n = Math.min(7, daily.time.length);
      trendState.days = daily.time.slice(0,n);
      trendState.hi = (daily.temperature_2m_max || []).slice(0,n).map(Number);
      trendState.lo = (daily.temperature_2m_min || []).slice(0,n).map(Number);
      trendState.codes = (daily.weather_code || []).slice(0,n).map(Number);

      // 尺寸准备 + 绘制
      resizeTrendCanvas();
    }

    function drawTrendChart(){
      const daily = trendState.days;
      const hi = trendState.hi;
      const lo = trendState.lo;
      if (!daily?.length || !hi?.length || !lo?.length) return;

      const ctx2 = trendCanvas.getContext("2d");
      const w = trendWrap.getBoundingClientRect().width;
      const h = trendCanvas.getBoundingClientRect().height;

      ctx2.clearRect(0,0,w,h);

      // 画布内边距
      const padL = 34, padR = 16, padT = 18, padB = 28;
      const innerW = Math.max(1, w - padL - padR);
      const innerH = Math.max(1, h - padT - padB);

      // y 范围：留余量
      const all = hi.concat(lo).filter(v => Number.isFinite(v));
      if (!all.length) return;
      let yMin = Math.min(...all);
      let yMax = Math.max(...all);
      const margin = Math.max(2, (yMax - yMin) * 0.18);
      yMin -= margin;
      yMax += margin;

      const xAt = (i) => padL + (innerW * (daily.length === 1 ? 0.5 : i/(daily.length-1)));
      const yAt = (v) => padT + (1 - (v - yMin)/(yMax - yMin)) * innerH;

      // 背景微光网格
      ctx2.save();
      ctx2.globalAlpha = 0.55;
      ctx2.strokeStyle = "rgba(0,231,255,0.12)";
      ctx2.lineWidth = 1;
      const gridY = 4;
      for (let j=0;j<=gridY;j++){
        const yy = padT + (innerH * j/gridY);
        ctx2.beginPath();
        ctx2.moveTo(padL, yy);
        ctx2.lineTo(padL + innerW, yy);
        ctx2.stroke();
      }
      ctx2.restore();

      // X 轴日期标注（简洁：月日）
      ctx2.save();
      ctx2.fillStyle = "rgba(210,240,255,0.70)";
      ctx2.font = '600 12px "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx2.textAlign = "center";
      ctx2.textBaseline = "top";
      for (let i=0;i<daily.length;i++){
        const xx = xAt(i);
        ctx2.fillText(fmtZhMD(daily[i]).replace("月","/").replace("日",""), xx, padT + innerH + 8);
      }
      ctx2.restore();

      // 计算点位并缓存用于 hover
      trendState.points = daily.map((dayIso, i) => {
        return {
          i,
          x: xAt(i),
          yHi: yAt(hi[i]),
          yLo: yAt(lo[i]),
          dayIso,
          hi: hi[i],
          lo: lo[i],
          code: trendState.codes[i]
        };
      });

      // 绘制函数：折线 + 光晕
      function drawLine(which){
        const isHi = which === "hi";
        const getY = (p) => isHi ? p.yHi : p.yLo;

        ctx2.save();
        ctx2.lineWidth = 2;
        ctx2.strokeStyle = isHi ? "rgba(0,231,255,0.92)" : "rgba(255,43,214,0.80)";
        ctx2.shadowColor = isHi ? "rgba(0,231,255,0.35)" : "rgba(255,43,214,0.28)";
        ctx2.shadowBlur = 14;

        ctx2.beginPath();
        trendState.points.forEach((p, idx) => {
          const y = getY(p);
          if (idx === 0) ctx2.moveTo(p.x, y);
          else ctx2.lineTo(p.x, y);
        });
        ctx2.stroke();
        ctx2.restore();

        // 节点
        ctx2.save();
        trendState.points.forEach((p) => {
          const y = getY(p);
          // 外光
          ctx2.beginPath();
          ctx2.fillStyle = isHi ? "rgba(0,231,255,0.22)" : "rgba(255,43,214,0.20)";
          ctx2.arc(p.x, y, 7, 0, Math.PI*2);
          ctx2.fill();

          // 内核
          ctx2.beginPath();
          ctx2.fillStyle = isHi ? "rgba(0,231,255,0.92)" : "rgba(255,43,214,0.86)";
          ctx2.arc(p.x, y, 3.2, 0, Math.PI*2);
          ctx2.fill();
        });
        ctx2.restore();
      }

      // 先画最低，再画最高（层级更好看）
      drawLine("lo");
      drawLine("hi");

      // 左侧温度刻度（简洁 3 个）
      ctx2.save();
      ctx2.fillStyle = "rgba(210,240,255,0.65)";
      ctx2.font = '600 12px "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx2.textAlign = "right";
      ctx2.textBaseline = "middle";
      const ticks = 3;
      for (let t=0;t<=ticks;t++){
        const vv = yMin + (yMax-yMin) * (1 - t/ticks);
        const yy = yAt(vv);
        ctx2.fillText(`${Math.round(vv)}°`, padL - 8, yy);
      }
      ctx2.restore();
    }

    function nearestPoint(x, y){
      let best = null;
      let bestD = Infinity;
      for (const p of trendState.points){
        // 对两条线都算：取最近的节点（hi/lo 里更近的那个）
        const d1 = Math.hypot(x - p.x, y - p.yHi);
        const d2 = Math.hypot(x - p.x, y - p.yLo);
        const d = Math.min(d1, d2);
        if (d < bestD){
          bestD = d;
          best = p;
        }
      }
      return (best && bestD <= 26) ? best : null;
    }

    function showTip(p, x, y){
      const md = fmtZhMD(p.dayIso);
      const brief = weatherText(p.code).replace(/（.*?）/g,"");
      trendTip.innerHTML = `
        <div><b>${md}</b> · ${brief}</div>
        <div class="row"><span class="hi">高 ${fmt(p.hi,0)}°C</span><span class="lo">低 ${fmt(p.lo,0)}°C</span></div>
      `;
      trendTip.style.left = `${x}px`;
      trendTip.style.top = `${y}px`;
      trendTip.style.display = "block";
    }
    function hideTip(){
      trendTip.style.display = "none";
    }

    trendWrap.addEventListener("mousemove", (e) => {
      const rect = trendWrap.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const p = nearestPoint(x, y);
      if (!p) { hideTip(); return; }
      showTip(p, x, y);
    });
    trendWrap.addEventListener("mouseleave", hideTip);

    // 初始化
    requestAnimationFrame(() => {
      resizeTrendCanvas();
    });

    fetchWeather();
    setupAuto();
  </script>
</body>
</html>
